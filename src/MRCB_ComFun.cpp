#include "MRCB.h"
#include <errno.h>   
#include <string.h>  
/* constants -----------------------------------------------------------------*/
#define MAX_VAR_EPH SQR(300.0)  /* max variance eph to reject satellite (m^2) */

static const double gpst0[]={1980,1, 6,0,0,0}; /* gps time reference */
static const double gst0 []={1999,8,22,0,0,0}; /* galileo system time reference */
static const double bdt0 []={2006,1, 1,0,0,0}; /* beidou time reference */

static double leaps[MAXLEAPS+1][7]={ /* leap seconds (y,m,d,h,m,s,utc-gpst) */
    {2017,1,1,0,0,0,-18},
    {2015,7,1,0,0,0,-17},
    {2012,7,1,0,0,0,-16},
    {2009,1,1,0,0,0,-15},
    {2006,1,1,0,0,0,-14},
    {1999,1,1,0,0,0,-13},
    {1997,7,1,0,0,0,-12},
    {1996,1,1,0,0,0,-11},
    {1994,7,1,0,0,0,-10},
    {1993,7,1,0,0,0, -9},
    {1992,7,1,0,0,0, -8},
    {1991,1,1,0,0,0, -7},
    {1990,1,1,0,0,0, -6},
    {1988,1,1,0,0,0, -5},
    {1985,7,1,0,0,0, -4},
    {1983,7,1,0,0,0, -3},
    {1982,7,1,0,0,0, -2},
    {1981,7,1,0,0,0, -1},
    {0}
};
const double chisqr[100]={      /* chi-sqr(n) (alpha=0.001) */
    10.8,13.8,16.3,18.5,20.5,22.5,24.3,26.1,27.9,29.6,
    31.3,32.9,34.5,36.1,37.7,39.3,40.8,42.3,43.8,45.3,
    46.8,48.3,49.7,51.2,52.6,54.1,55.5,56.9,58.3,59.7,
    61.1,62.5,63.9,65.2,66.6,68.0,69.3,70.7,72.1,73.4,
    74.7,76.0,77.3,78.6,80.0,81.3,82.6,84.0,85.4,86.7,
    88.0,89.3,90.6,91.9,93.3,94.7,96.0,97.4,98.7,100 ,
    101 ,102 ,103 ,104 ,105 ,107 ,108 ,109 ,110 ,112 ,
    113 ,114 ,115 ,116 ,118 ,119 ,120 ,122 ,123 ,125 ,
    126 ,127 ,128 ,129 ,131 ,132 ,133 ,134 ,135 ,137 ,
    138 ,139 ,140 ,142 ,143 ,144 ,145 ,147 ,148 ,149
};
const double diacri[1500]= /* critical value for statistical hypothesis testing: alfa0=0.001,power=0.8 */
{
	1.082753e+01,5.864970e+00,4.211147e+00,3.384505e+00,2.888732e+00,2.558391e+00,2.322580e+00,2.145846e+00,2.008496e+00,1.898711e+00,
	1.808972e+00,1.734265e+00,1.671119e+00,1.617056e+00,1.570258e+00,1.529360e+00,1.493322e+00,1.461330e+00,1.432747e+00,1.407058e+00,
	1.383851e+00,1.362785e+00,1.343581e+00,1.326006e+00,1.309862e+00,1.294985e+00,1.281233e+00,1.268486e+00,1.256637e+00,1.245599e+00,
	1.235291e+00,1.225644e+00,1.216599e+00,1.208101e+00,1.200104e+00,1.192566e+00,1.185448e+00,1.178718e+00,1.172346e+00,1.166304e+00,
	1.160568e+00,1.155116e+00,1.149928e+00,1.144985e+00,1.140272e+00,1.135773e+00,1.131474e+00,1.127362e+00,1.123427e+00,1.119657e+00,
	1.116042e+00,1.112573e+00,1.109243e+00,1.106042e+00,1.102964e+00,1.100003e+00,1.097151e+00,1.094404e+00,1.091756e+00,1.089201e+00,
	1.086736e+00,1.084355e+00,1.082054e+00,1.079831e+00,1.077680e+00,1.075600e+00,1.073585e+00,1.071635e+00,1.069745e+00,1.067913e+00,
	1.066137e+00,1.064414e+00,1.062741e+00,1.061118e+00,1.059541e+00,1.058010e+00,1.056521e+00,1.055074e+00,1.053667e+00,1.052298e+00,
	1.050965e+00,1.049669e+00,1.048406e+00,1.047176e+00,1.045978e+00,1.044810e+00,1.043672e+00,1.042562e+00,1.041480e+00,1.040424e+00,
	1.039394e+00,1.038388e+00,1.037406e+00,1.036448e+00,1.035511e+00,1.034597e+00,1.033703e+00,1.032829e+00,1.031976e+00,1.031141e+00,
	1.030324e+00,1.029526e+00,1.028744e+00,1.027980e+00,1.027232e+00,1.026500e+00,1.025783e+00,1.025081e+00,1.024393e+00,1.023720e+00,
	1.023060e+00,1.022414e+00,1.021780e+00,1.021159e+00,1.020550e+00,1.019954e+00,1.019368e+00,1.018794e+00,1.018231e+00,1.017679e+00,
	1.017137e+00,1.016606e+00,1.016084e+00,1.015572e+00,1.015069e+00,1.014575e+00,1.014091e+00,1.013615e+00,1.013147e+00,1.012688e+00,
	1.012237e+00,1.011793e+00,1.011358e+00,1.010930e+00,1.010509e+00,1.010096e+00,1.009690e+00,1.009290e+00,1.008897e+00,1.008511e+00,
	1.008131e+00,1.007757e+00,1.007390e+00,1.007028e+00,1.006672e+00,1.006322e+00,1.005978e+00,1.005639e+00,1.005305e+00,1.004977e+00,
	1.004654e+00,1.004336e+00,1.004023e+00,1.003714e+00,1.003411e+00,1.003112e+00,1.002817e+00,1.002527e+00,1.002241e+00,1.001960e+00,
	1.001683e+00,1.001409e+00,1.001140e+00,1.000875e+00,1.000614e+00,1.000356e+00,1.000102e+00,9.998520e-01,9.996054e-01,9.993623e-01,
	9.991226e-01,9.988863e-01,9.986533e-01,9.984235e-01,9.981970e-01,9.979736e-01,9.977532e-01,9.975359e-01,9.973216e-01,9.971101e-01,
	9.969016e-01,9.966958e-01,9.964928e-01,9.962925e-01,9.960949e-01,9.958999e-01,9.957074e-01,9.955175e-01,9.953301e-01,9.951451e-01,
	9.949625e-01,9.947823e-01,9.946044e-01,9.944288e-01,9.942554e-01,9.940843e-01,9.939153e-01,9.937484e-01,9.935837e-01,9.934210e-01,
	9.932603e-01,9.931017e-01,9.929450e-01,9.927902e-01,9.926374e-01,9.924864e-01,9.923373e-01,9.921900e-01,9.920445e-01,9.919007e-01,
	9.917587e-01,9.916183e-01,9.914797e-01,9.913427e-01,9.912073e-01,9.910736e-01,9.909414e-01,9.908108e-01,9.906817e-01,9.905541e-01,
	9.904280e-01,9.903034e-01,9.901802e-01,9.900585e-01,9.899381e-01,9.898191e-01,9.897015e-01,9.895852e-01,9.894703e-01,9.893566e-01,
	9.892442e-01,9.891331e-01,9.890233e-01,9.889147e-01,9.888073e-01,9.887010e-01,9.885960e-01,9.884921e-01,9.883894e-01,9.882878e-01,
	9.881873e-01,9.880880e-01,9.879897e-01,9.878925e-01,9.877963e-01,9.877012e-01,9.876071e-01,9.875140e-01,9.874219e-01,9.873308e-01,
	9.872407e-01,9.871515e-01,9.870633e-01,9.869760e-01,9.868897e-01,9.868042e-01,9.867197e-01,9.866360e-01,9.865532e-01,9.864713e-01,
	9.863902e-01,9.863100e-01,9.862306e-01,9.861521e-01,9.860743e-01,9.859974e-01,9.859212e-01,9.858458e-01,9.857712e-01,9.856974e-01,
	9.856243e-01,9.855519e-01,9.854803e-01,9.854094e-01,9.853392e-01,9.852697e-01,9.852010e-01,9.851329e-01,9.850655e-01,9.849988e-01,
	9.849327e-01,9.848673e-01,9.848025e-01,9.847384e-01,9.846749e-01,9.846121e-01,9.845498e-01,9.844882e-01,9.844272e-01,9.843668e-01,
	9.843070e-01,9.842477e-01,9.841890e-01,9.841309e-01,9.840734e-01,9.840164e-01,9.839600e-01,9.839041e-01,9.838488e-01,9.837940e-01,
	9.837397e-01,9.836859e-01,9.836327e-01,9.835799e-01,9.835277e-01,9.834759e-01,9.834247e-01,9.833739e-01,9.833236e-01,9.832738e-01,
	9.832245e-01,9.831756e-01,9.831272e-01,9.830793e-01,9.830317e-01,9.829847e-01,9.829381e-01,9.828919e-01,9.828461e-01,9.828008e-01,
	9.827559e-01,9.827114e-01,9.826673e-01,9.826236e-01,9.825804e-01,9.825375e-01,9.824950e-01,9.824530e-01,9.824113e-01,9.823700e-01,
	9.823290e-01,9.822885e-01,9.822483e-01,9.822085e-01,9.821690e-01,9.821299e-01,9.820912e-01,9.820528e-01,9.820148e-01,9.819771e-01,
	9.819397e-01,9.819027e-01,9.818661e-01,9.818297e-01,9.817937e-01,9.817580e-01,9.817226e-01,9.816876e-01,9.816528e-01,9.816184e-01,
	9.815843e-01,9.815505e-01,9.815170e-01,9.814838e-01,9.814509e-01,9.814183e-01,9.813859e-01,9.813539e-01,9.813221e-01,9.812907e-01,
	9.812595e-01,9.812286e-01,9.811979e-01,9.811676e-01,9.811375e-01,9.811076e-01,9.810781e-01,9.810488e-01,9.810197e-01,9.809909e-01,
	9.809624e-01,9.809341e-01,9.809061e-01,9.808783e-01,9.808507e-01,9.808234e-01,9.807964e-01,9.807696e-01,9.807430e-01,9.807166e-01,
	9.806905e-01,9.806646e-01,9.806389e-01,9.806135e-01,9.805883e-01,9.805633e-01,9.805385e-01,9.805139e-01,9.804896e-01,9.804654e-01,
	9.804415e-01,9.804178e-01,9.803943e-01,9.803710e-01,9.803478e-01,9.803249e-01,9.803022e-01,9.802797e-01,9.802574e-01,9.802353e-01,
	9.802134e-01,9.801917e-01,9.801701e-01,9.801488e-01,9.801276e-01,9.801066e-01,9.800858e-01,9.800652e-01,9.800447e-01,9.800245e-01,
	9.800044e-01,9.799845e-01,9.799647e-01,9.799451e-01,9.799257e-01,9.799065e-01,9.798874e-01,9.798685e-01,9.798498e-01,9.798312e-01,
	9.798128e-01,9.797946e-01,9.797765e-01,9.797585e-01,9.797407e-01,9.797231e-01,9.797057e-01,9.796883e-01,9.796712e-01,9.796541e-01,
	9.796373e-01,9.796205e-01,9.796040e-01,9.795875e-01,9.795712e-01,9.795551e-01,9.795391e-01,9.795232e-01,9.795075e-01,9.794919e-01,
	9.794764e-01,9.794611e-01,9.794459e-01,9.794308e-01,9.794159e-01,9.794011e-01,9.793864e-01,9.793719e-01,9.793575e-01,9.793432e-01,
	9.793291e-01,9.793150e-01,9.793011e-01,9.792873e-01,9.792737e-01,9.792601e-01,9.792467e-01,9.792334e-01,9.792202e-01,9.792071e-01,
	9.791942e-01,9.791813e-01,9.791686e-01,9.791560e-01,9.791435e-01,9.791311e-01,9.791188e-01,9.791066e-01,9.790945e-01,9.790826e-01,
	9.790707e-01,9.790590e-01,9.790473e-01,9.790358e-01,9.790243e-01,9.790130e-01,9.790018e-01,9.789907e-01,9.789796e-01,9.789687e-01,
	9.789579e-01,9.789471e-01,9.789365e-01,9.789259e-01,9.789155e-01,9.789051e-01,9.788949e-01,9.788847e-01,9.788747e-01,9.788647e-01,
	9.788548e-01,9.788450e-01,9.788353e-01,9.788257e-01,9.788161e-01,9.788067e-01,9.787973e-01,9.787881e-01,9.787789e-01,9.787698e-01,
	9.787608e-01,9.787518e-01,9.787430e-01,9.787342e-01,9.787256e-01,9.787170e-01,9.787084e-01,9.787000e-01,9.786916e-01,9.786833e-01,
	9.786751e-01,9.786670e-01,9.786590e-01,9.786510e-01,9.786431e-01,9.786353e-01,9.786275e-01,9.786199e-01,9.786123e-01,9.786047e-01,
	9.785973e-01,9.785899e-01,9.785826e-01,9.785754e-01,9.785682e-01,9.785611e-01,9.785541e-01,9.785471e-01,9.785402e-01,9.785334e-01,
	9.785267e-01,9.785200e-01,9.785134e-01,9.785068e-01,9.785003e-01,9.784939e-01,9.784875e-01,9.784812e-01,9.784750e-01,9.784688e-01,
	9.784627e-01,9.784567e-01,9.784507e-01,9.784448e-01,9.784389e-01,9.784332e-01,9.784274e-01,9.784217e-01,9.784161e-01,9.784106e-01,
	9.784051e-01,9.783996e-01,9.783942e-01,9.783889e-01,9.783836e-01,9.783784e-01,9.783733e-01,9.783682e-01,9.783631e-01,9.783581e-01,
	9.783532e-01,9.783483e-01,9.783435e-01,9.783387e-01,9.783340e-01,9.783293e-01,9.783247e-01,9.783201e-01,9.783156e-01,9.783111e-01,
	9.783067e-01,9.783024e-01,9.782980e-01,9.782938e-01,9.782896e-01,9.782854e-01,9.782813e-01,9.782772e-01,9.782732e-01,9.782692e-01,
	9.782653e-01,9.782614e-01,9.782576e-01,9.782538e-01,9.782501e-01,9.782464e-01,9.782427e-01,9.782391e-01,9.782356e-01,9.782320e-01,
	9.782286e-01,9.782251e-01,9.782218e-01,9.782184e-01,9.782151e-01,9.782119e-01,9.782087e-01,9.782055e-01,9.782024e-01,9.781993e-01,
	9.781962e-01,9.781932e-01,9.781903e-01,9.781874e-01,9.781845e-01,9.781816e-01,9.781788e-01,9.781761e-01,9.781734e-01,9.781707e-01,
	9.781680e-01,9.781654e-01,9.781628e-01,9.781603e-01,9.781578e-01,9.781554e-01,9.781529e-01,9.781506e-01,9.781482e-01,9.781459e-01,
	9.781436e-01,9.781414e-01,9.781392e-01,9.781370e-01,9.781349e-01,9.781328e-01,9.781307e-01,9.781287e-01,9.781267e-01,9.781248e-01,
	9.781228e-01,9.781209e-01,9.781191e-01,9.781173e-01,9.781155e-01,9.781137e-01,9.781120e-01,9.781103e-01,9.781086e-01,9.781070e-01,
	9.781054e-01,9.781038e-01,9.781023e-01,9.781008e-01,9.780993e-01,9.780979e-01,9.780964e-01,9.780951e-01,9.780937e-01,9.780924e-01,
	9.780911e-01,9.780898e-01,9.780886e-01,9.780874e-01,9.780862e-01,9.780850e-01,9.780839e-01,9.780828e-01,9.780818e-01,9.780807e-01,
	9.780797e-01,9.780787e-01,9.780778e-01,9.780769e-01,9.780760e-01,9.780751e-01,9.780742e-01,9.780734e-01,9.780726e-01,9.780719e-01,
	9.780711e-01,9.780704e-01,9.780697e-01,9.780691e-01,9.780684e-01,9.780678e-01,9.780672e-01,9.780667e-01,9.780661e-01,9.780656e-01,
	9.780651e-01,9.780647e-01,9.780642e-01,9.780638e-01,9.780634e-01,9.780630e-01,9.780627e-01,9.780624e-01,9.780621e-01,9.780618e-01,
	9.780615e-01,9.780613e-01,9.780611e-01,9.780609e-01,9.780607e-01,9.780606e-01,9.780605e-01,9.780604e-01,9.780603e-01,9.780603e-01,
	9.780602e-01,9.780602e-01,9.780602e-01,9.780603e-01,9.780603e-01,9.780604e-01,9.780605e-01,9.780606e-01,9.780607e-01,9.780609e-01,
	9.780611e-01,9.780613e-01,9.780615e-01,9.780617e-01,9.780620e-01,9.780622e-01,9.780625e-01,9.780628e-01,9.780632e-01,9.780635e-01,
	9.780639e-01,9.780643e-01,9.780647e-01,9.780651e-01,9.780656e-01,9.780660e-01,9.780665e-01,9.780670e-01,9.780675e-01,9.780681e-01,
	9.780686e-01,9.780692e-01,9.780698e-01,9.780704e-01,9.780710e-01,9.780717e-01,9.780723e-01,9.780730e-01,9.780737e-01,9.780744e-01,
	9.780751e-01,9.780759e-01,9.780766e-01,9.780774e-01,9.780782e-01,9.780790e-01,9.780798e-01,9.780807e-01,9.780815e-01,9.780824e-01,
	9.780833e-01,9.780842e-01,9.780851e-01,9.780860e-01,9.780870e-01,9.780880e-01,9.780889e-01,9.780899e-01,9.780909e-01,9.780920e-01,
	9.780930e-01,9.780941e-01,9.780951e-01,9.780962e-01,9.780973e-01,9.780984e-01,9.780996e-01,9.781007e-01,9.781019e-01,9.781030e-01,
	9.781042e-01,9.781054e-01,9.781066e-01,9.781078e-01,9.781091e-01,9.781103e-01,9.781116e-01,9.781129e-01,9.781142e-01,9.781155e-01,
	9.781168e-01,9.781181e-01,9.781195e-01,9.781208e-01,9.781222e-01,9.781236e-01,9.781250e-01,9.781264e-01,9.781278e-01,9.781292e-01,
	9.781307e-01,9.781321e-01,9.781336e-01,9.781351e-01,9.781366e-01,9.781381e-01,9.781396e-01,9.781411e-01,9.781426e-01,9.781442e-01,
	9.781458e-01,9.781473e-01,9.781489e-01,9.781505e-01,9.781521e-01,9.781537e-01,9.781554e-01,9.781570e-01,9.781587e-01,9.781603e-01,
	9.781620e-01,9.781637e-01,9.781654e-01,9.781671e-01,9.781688e-01,9.781705e-01,9.781723e-01,9.781740e-01,9.781758e-01,9.781775e-01,
	9.781793e-01,9.781811e-01,9.781829e-01,9.781847e-01,9.781865e-01,9.781884e-01,9.781902e-01,9.781921e-01,9.781939e-01,9.781958e-01,
	9.781977e-01,9.781996e-01,9.782015e-01,9.782034e-01,9.782053e-01,9.782072e-01,9.782091e-01,9.782111e-01,9.782130e-01,9.782150e-01,
	9.782170e-01,9.782189e-01,9.782209e-01,9.782229e-01,9.782249e-01,9.782270e-01,9.782290e-01,9.782310e-01,9.782331e-01,9.782351e-01,
	9.782372e-01,9.782392e-01,9.782413e-01,9.782434e-01,9.782455e-01,9.782476e-01,9.782497e-01,9.782518e-01,9.782539e-01,9.782561e-01,
	9.782582e-01,9.782604e-01,9.782625e-01,9.782647e-01,9.782668e-01,9.782690e-01,9.782712e-01,9.782734e-01,9.782756e-01,9.782778e-01,
	9.782800e-01,9.782823e-01,9.782845e-01,9.782867e-01,9.782890e-01,9.782912e-01,9.782935e-01,9.782958e-01,9.782980e-01,9.783003e-01,
	9.783026e-01,9.783049e-01,9.783072e-01,9.783095e-01,9.783118e-01,9.783142e-01,9.783165e-01,9.783188e-01,9.783212e-01,9.783235e-01,
	9.783259e-01,9.783283e-01,9.783306e-01,9.783330e-01,9.783354e-01,9.783378e-01,9.783402e-01,9.783426e-01,9.783450e-01,9.783474e-01,
	9.783498e-01,9.783523e-01,9.783547e-01,9.783571e-01,9.783596e-01,9.783620e-01,9.783645e-01,9.783670e-01,9.783694e-01,9.783719e-01,
	9.783744e-01,9.783769e-01,9.783794e-01,9.783819e-01,9.783844e-01,9.783869e-01,9.783894e-01,9.783919e-01,9.783944e-01,9.783970e-01,
	9.783995e-01,9.784021e-01,9.784046e-01,9.784072e-01,9.784097e-01,9.784123e-01,9.784149e-01,9.784174e-01,9.784200e-01,9.784226e-01,
	9.784252e-01,9.784278e-01,9.784304e-01,9.784330e-01,9.784356e-01,9.784382e-01,9.784408e-01,9.784435e-01,9.784461e-01,9.784487e-01,
	9.784514e-01,9.784540e-01,9.784567e-01,9.784593e-01,9.784620e-01,9.784647e-01,9.784673e-01,9.784700e-01,9.784727e-01,9.784754e-01,
	9.784780e-01,9.784807e-01,9.784834e-01,9.784861e-01,9.784888e-01,9.784915e-01,9.784943e-01,9.784970e-01,9.784997e-01,9.785024e-01,
	9.785052e-01,9.785079e-01,9.785106e-01,9.785134e-01,9.785161e-01,9.785189e-01,9.785216e-01,9.785244e-01,9.785271e-01,9.785299e-01,
	9.785327e-01,9.785355e-01,9.785382e-01,9.785410e-01,9.785438e-01,9.785466e-01,9.785494e-01,9.785522e-01,9.785550e-01,9.785578e-01,
	9.785606e-01,9.785634e-01,9.785662e-01,9.785690e-01,9.785719e-01,9.785747e-01,9.785775e-01,9.785804e-01,9.785832e-01,9.785860e-01,
	9.785889e-01,9.785917e-01,9.785946e-01,9.785974e-01,9.786003e-01,9.786032e-01,9.786060e-01,9.786089e-01,9.786118e-01,9.786146e-01,
	9.786175e-01,9.786204e-01,9.786233e-01,9.786262e-01,9.786291e-01,9.786319e-01,9.786348e-01,9.786377e-01,9.786406e-01,9.786435e-01,
	9.786465e-01,9.786494e-01,9.786523e-01,9.786552e-01,9.786581e-01,9.786610e-01,9.786640e-01,9.786669e-01,9.786698e-01,9.786728e-01,
	9.786757e-01,9.786786e-01,9.786816e-01,9.786845e-01,9.786875e-01,9.786904e-01,9.786934e-01,9.786963e-01,9.786993e-01,9.787022e-01,
	9.787052e-01,9.787082e-01,9.787111e-01,9.787141e-01,9.787171e-01,9.787201e-01,9.787230e-01,9.787260e-01,9.787290e-01,9.787320e-01,
	9.787350e-01,9.787380e-01,9.787410e-01,9.787440e-01,9.787470e-01,9.787500e-01,9.787530e-01,9.787560e-01,9.787590e-01,9.787620e-01,
	9.787650e-01,9.787680e-01,9.787710e-01,9.787740e-01,9.787771e-01,9.787801e-01,9.787831e-01,9.787861e-01,9.787892e-01,9.787922e-01,
	9.787952e-01,9.787982e-01,9.788013e-01,9.788043e-01,9.788074e-01,9.788104e-01,9.788134e-01,9.788165e-01,9.788195e-01,9.788226e-01,
	9.788256e-01,9.788287e-01,9.788318e-01,9.788348e-01,9.788379e-01,9.788409e-01,9.788440e-01,9.788471e-01,9.788501e-01,9.788532e-01,
	9.788563e-01,9.788593e-01,9.788624e-01,9.788655e-01,9.788686e-01,9.788716e-01,9.788747e-01,9.788778e-01,9.788809e-01,9.788840e-01,
	9.788870e-01,9.788901e-01,9.788932e-01,9.788963e-01,9.788994e-01,9.789025e-01,9.789056e-01,9.789087e-01,9.789118e-01,9.789149e-01,
	9.789180e-01,9.789211e-01,9.789242e-01,9.789273e-01,9.789304e-01,9.789335e-01,9.789366e-01,9.789397e-01,9.789429e-01,9.789460e-01,
	9.789491e-01,9.789522e-01,9.789553e-01,9.789584e-01,9.789616e-01,9.789647e-01,9.789678e-01,9.789709e-01,9.789740e-01,9.789772e-01,
	9.789803e-01,9.789834e-01,9.789866e-01,9.789897e-01,9.789928e-01,9.789960e-01,9.789991e-01,9.790022e-01,9.790054e-01,9.790085e-01,
	9.790116e-01,9.790148e-01,9.790179e-01,9.790211e-01,9.790242e-01,9.790273e-01,9.790305e-01,9.790336e-01,9.790368e-01,9.790399e-01,
	9.790431e-01,9.790462e-01,9.790494e-01,9.790525e-01,9.790557e-01,9.790588e-01,9.790620e-01,9.790652e-01,9.790683e-01,9.790715e-01,
	9.790746e-01,9.790778e-01,9.790809e-01,9.790841e-01,9.790873e-01,9.790904e-01,9.790936e-01,9.790968e-01,9.790999e-01,9.791031e-01,
	9.791062e-01,9.791094e-01,9.791126e-01,9.791158e-01,9.791189e-01,9.791221e-01,9.791253e-01,9.791284e-01,9.791316e-01,9.791348e-01,
	9.791379e-01,9.791411e-01,9.791443e-01,9.791475e-01,9.791506e-01,9.791538e-01,9.791570e-01,9.791602e-01,9.791634e-01,9.791665e-01,
	9.791697e-01,9.791729e-01,9.791761e-01,9.791793e-01,9.791824e-01,9.791856e-01,9.791888e-01,9.791920e-01,9.791952e-01,9.791984e-01,
	9.792015e-01,9.792047e-01,9.792079e-01,9.792111e-01,9.792143e-01,9.792175e-01,9.792207e-01,9.792238e-01,9.792270e-01,9.792302e-01,
	9.792334e-01,9.792366e-01,9.792398e-01,9.792430e-01,9.792462e-01,9.792494e-01,9.792526e-01,9.792557e-01,9.792589e-01,9.792621e-01,
	9.792653e-01,9.792685e-01,9.792717e-01,9.792749e-01,9.792781e-01,9.792813e-01,9.792845e-01,9.792877e-01,9.792909e-01,9.792941e-01,
	9.792973e-01,9.793005e-01,9.793037e-01,9.793069e-01,9.793100e-01,9.793132e-01,9.793164e-01,9.793196e-01,9.793228e-01,9.793260e-01,
	9.793292e-01,9.793324e-01,9.793356e-01,9.793388e-01,9.793420e-01,9.793452e-01,9.793484e-01,9.793516e-01,9.793548e-01,9.793580e-01,
	9.793612e-01,9.793644e-01,9.793676e-01,9.793708e-01,9.793740e-01,9.793772e-01,9.793804e-01,9.793836e-01,9.793868e-01,9.793900e-01,
	9.793932e-01,9.793964e-01,9.793996e-01,9.794028e-01,9.794060e-01,9.794092e-01,9.794124e-01,9.794156e-01,9.794188e-01,9.794220e-01,
	9.794252e-01,9.794284e-01,9.794316e-01,9.794348e-01,9.794380e-01,9.794412e-01,9.794444e-01,9.794476e-01,9.794508e-01,9.794540e-01,
	9.794572e-01,9.794604e-01,9.794636e-01,9.794668e-01,9.794700e-01,9.794732e-01,9.794764e-01,9.794796e-01,9.794828e-01,9.794860e-01,
	9.794892e-01,9.794924e-01,9.794956e-01,9.794988e-01,9.795020e-01,9.795052e-01,9.795084e-01,9.795116e-01,9.795148e-01,9.795180e-01,
	9.795212e-01,9.795244e-01,9.795276e-01,9.795308e-01,9.795340e-01,9.795372e-01,9.795404e-01,9.795436e-01,9.795468e-01,9.795500e-01,
	9.795532e-01,9.795564e-01,9.795595e-01,9.795627e-01,9.795659e-01,9.795691e-01,9.795723e-01,9.795755e-01,9.795787e-01,9.795819e-01,
	9.795851e-01,9.795883e-01,9.795915e-01,9.795947e-01,9.795979e-01,9.796011e-01,9.796043e-01,9.796074e-01,9.796106e-01,9.796138e-01,
	9.796170e-01,9.796202e-01,9.796234e-01,9.796266e-01,9.796298e-01,9.796330e-01,9.796361e-01,9.796393e-01,9.796425e-01,9.796457e-01,
	9.796489e-01,9.796521e-01,9.796553e-01,9.796585e-01,9.796616e-01,9.796648e-01,9.796680e-01,9.796712e-01,9.796744e-01,9.796776e-01,
	9.796807e-01,9.796839e-01,9.796871e-01,9.796903e-01,9.796935e-01,9.796967e-01,9.796998e-01,9.797030e-01,9.797062e-01,9.797094e-01,
	9.797126e-01,9.797157e-01,9.797189e-01,9.797221e-01,9.797253e-01,9.797284e-01,9.797316e-01,9.797348e-01,9.797380e-01,9.797411e-01,
	9.797443e-01,9.797475e-01,9.797507e-01,9.797538e-01,9.797570e-01,9.797602e-01,9.797634e-01,9.797665e-01,9.797697e-01,9.797729e-01,
	9.797760e-01,9.797792e-01,9.797824e-01,9.797855e-01,9.797887e-01,9.797919e-01,9.797951e-01,9.797982e-01,9.798014e-01,9.798045e-01,
	9.798077e-01,9.798109e-01,9.798140e-01,9.798172e-01,9.798204e-01,9.798235e-01,9.798267e-01,9.798298e-01,9.798330e-01,9.798362e-01,
	9.798393e-01,9.798425e-01,9.798456e-01,9.798488e-01,9.798520e-01,9.798551e-01,9.798583e-01,9.798614e-01,9.798646e-01,9.798677e-01,
	9.798709e-01,9.798740e-01,9.798772e-01,9.798803e-01,9.798835e-01,9.798866e-01,9.798898e-01,9.798929e-01,9.798961e-01,9.798992e-01,
	9.799024e-01,9.799055e-01,9.799087e-01,9.799118e-01,9.799150e-01,9.799181e-01,9.799213e-01,9.799244e-01,9.799275e-01,9.799307e-01,
	9.799338e-01,9.799370e-01,9.799401e-01,9.799432e-01,9.799464e-01,9.799495e-01,9.799527e-01,9.799558e-01,9.799589e-01,9.799621e-01,
	9.799652e-01,9.799683e-01,9.799715e-01,9.799746e-01,9.799777e-01,9.799809e-01,9.799840e-01,9.799871e-01,9.799903e-01,9.799934e-01,
	9.799965e-01,9.799996e-01,9.800028e-01,9.800059e-01,9.800090e-01,9.800121e-01,9.800153e-01,9.800184e-01,9.800215e-01,9.800246e-01,
	9.800277e-01,9.800309e-01,9.800340e-01,9.800371e-01,9.800402e-01,9.800433e-01,9.800465e-01,9.800496e-01,9.800527e-01,9.800558e-01,
	9.800589e-01,9.800620e-01,9.800651e-01,9.800682e-01,9.800714e-01,9.800745e-01,9.800776e-01,9.800807e-01,9.800838e-01,9.800869e-01,
	9.800900e-01,9.800931e-01,9.800962e-01,9.800993e-01,9.801024e-01,9.801055e-01,9.801086e-01,9.801117e-01,9.801148e-01,9.801179e-01,
	9.801210e-01,9.801241e-01,9.801272e-01,9.801303e-01,9.801334e-01,9.801365e-01,9.801396e-01,9.801427e-01,9.801458e-01,9.801489e-01,
	9.801520e-01,9.801550e-01,9.801581e-01,9.801612e-01,9.801643e-01,9.801674e-01,9.801705e-01,9.801736e-01,9.801767e-01,9.801797e-01
};
const double ratiotab01[31][64]={
	{0.0000,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
	{0.0010,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
	{0.0012,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.97,0.97,0.97,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99},
	{0.0015,0.87,0.87,0.88,0.88,0.89,0.89,0.89,0.89,0.91,0.92,0.92,0.92,0.92,0.93,0.93,0.93,0.93,0.93,0.93,0.93,0.93,0.94,0.94,0.94,0.94,0.94,0.94,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97,0.97},
	{0.0020,0.78,0.78,0.80,0.80,0.81,0.82,0.83,0.84,0.84,0.86,0.86,0.86,0.87,0.88,0.88,0.88,0.89,0.89,0.90,0.90,0.90,0.90,0.90,0.90,0.91,0.91,0.91,0.92,0.92,0.92,0.92,0.93,0.93,0.93,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.96},
	{0.0050,0.54,0.54,0.57,0.57,0.59,0.64,0.64,0.68,0.68,0.69,0.71,0.72,0.73,0.74,0.75,0.75,0.77,0.78,0.80,0.80,0.80,0.80,0.80,0.81,0.82,0.82,0.82,0.84,0.84,0.84,0.84,0.85,0.85,0.86,0.86,0.86,0.86,0.87,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.89,0.89,0.89,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91,0.91},
	{0.0100,0.36,0.38,0.41,0.43,0.45,0.51,0.52,0.57,0.57,0.59,0.61,0.62,0.64,0.65,0.67,0.67,0.68,0.69,0.72,0.72,0.72,0.72,0.72,0.74,0.76,0.76,0.77,0.79,0.79,0.79,0.79,0.81,0.81,0.82,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.85,0.85,0.85,0.85,0.85,0.85,0.85,0.85,0.85,0.87,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88,0.88},
	{0.0150,0.27,0.29,0.32,0.36,0.38,0.43,0.46,0.51,0.52,0.53,0.55,0.56,0.58,0.60,0.62,0.62,0.64,0.65,0.67,0.67,0.69,0.69,0.69,0.71,0.74,0.74,0.74,0.76,0.76,0.76,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.82,0.82,0.83,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.84,0.85,0.85,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.87,0.87,0.87,0.88},
	{0.0200,0.21,0.24,0.27,0.30,0.33,0.38,0.42,0.46,0.48,0.49,0.52,0.52,0.55,0.57,0.59,0.59,0.62,0.62,0.65,0.65,0.67,0.67,0.67,0.70,0.72,0.72,0.72,0.74,0.75,0.75,0.75,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.80,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.83,0.83,0.83,0.84,0.84,0.84,0.85,0.85,0.85,0.85,0.85,0.85,0.86,0.86,0.86,0.87},
	{0.0250,0.19,0.22,0.24,0.27,0.29,0.35,0.39,0.42,0.45,0.46,0.49,0.49,0.53,0.54,0.56,0.56,0.60,0.60,0.63,0.64,0.65,0.66,0.66,0.68,0.71,0.71,0.71,0.72,0.72,0.73,0.74,0.75,0.75,0.77,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.83,0.83,0.83,0.84,0.84,0.85,0.85,0.85,0.85,0.86,0.86,0.86,0.87},
	{0.0300,0.17,0.20,0.22,0.24,0.26,0.32,0.35,0.40,0.42,0.44,0.47,0.47,0.51,0.53,0.54,0.55,0.58,0.59,0.62,0.62,0.64,0.65,0.65,0.67,0.70,0.70,0.70,0.71,0.71,0.72,0.73,0.74,0.75,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.85,0.85,0.85,0.85,0.86,0.86,0.86},
	{0.0350,0.16,0.18,0.20,0.22,0.24,0.30,0.33,0.38,0.40,0.42,0.45,0.45,0.49,0.51,0.53,0.54,0.57,0.58,0.61,0.61,0.63,0.64,0.65,0.66,0.69,0.69,0.69,0.71,0.71,0.72,0.72,0.74,0.74,0.75,0.75,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.79,0.80,0.81,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.85,0.85,0.85,0.85,0.86,0.86},
	{0.0400,0.15,0.17,0.18,0.21,0.22,0.27,0.31,0.36,0.39,0.40,0.44,0.44,0.48,0.50,0.52,0.53,0.56,0.56,0.60,0.61,0.62,0.64,0.65,0.66,0.68,0.69,0.69,0.70,0.71,0.71,0.71,0.73,0.74,0.74,0.75,0.75,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.79,0.80,0.81,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.84,0.84,0.84,0.85,0.85,0.85,0.85,0.85,0.86},
	{0.0450,0.14,0.16,0.17,0.19,0.21,0.26,0.29,0.34,0.38,0.39,0.43,0.44,0.48,0.49,0.51,0.52,0.56,0.56,0.59,0.60,0.61,0.63,0.65,0.65,0.67,0.68,0.68,0.70,0.71,0.71,0.71,0.73,0.73,0.74,0.74,0.75,0.75,0.76,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85,0.85,0.86},
	{0.0500,0.13,0.15,0.16,0.18,0.19,0.24,0.28,0.32,0.37,0.39,0.42,0.43,0.47,0.48,0.51,0.52,0.55,0.55,0.59,0.60,0.61,0.63,0.64,0.64,0.67,0.68,0.68,0.69,0.71,0.71,0.71,0.72,0.73,0.74,0.74,0.75,0.75,0.76,0.76,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.79,0.80,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.84,0.85,0.86},
	{0.0550,0.12,0.14,0.15,0.17,0.18,0.23,0.27,0.31,0.36,0.38,0.41,0.42,0.46,0.48,0.50,0.51,0.54,0.55,0.58,0.59,0.60,0.62,0.64,0.64,0.66,0.67,0.68,0.69,0.70,0.70,0.70,0.72,0.73,0.73,0.74,0.75,0.75,0.75,0.76,0.77,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85,0.86},
	{0.0600,0.12,0.13,0.15,0.16,0.17,0.21,0.26,0.30,0.36,0.37,0.40,0.42,0.46,0.47,0.50,0.51,0.54,0.54,0.58,0.59,0.60,0.62,0.63,0.63,0.66,0.67,0.67,0.69,0.70,0.70,0.70,0.71,0.72,0.73,0.74,0.74,0.75,0.75,0.76,0.76,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85,0.86},
	{0.0650,0.11,0.12,0.14,0.15,0.16,0.20,0.26,0.30,0.35,0.36,0.40,0.41,0.45,0.46,0.50,0.51,0.53,0.54,0.58,0.59,0.59,0.61,0.63,0.63,0.66,0.67,0.67,0.68,0.70,0.70,0.70,0.71,0.72,0.73,0.73,0.74,0.75,0.75,0.76,0.76,0.77,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85,0.85},
	{0.0700,0.11,0.12,0.13,0.14,0.15,0.20,0.25,0.30,0.35,0.36,0.39,0.41,0.45,0.46,0.49,0.50,0.53,0.54,0.58,0.58,0.59,0.61,0.63,0.63,0.66,0.66,0.67,0.68,0.69,0.69,0.70,0.71,0.72,0.73,0.73,0.74,0.74,0.75,0.76,0.76,0.77,0.77,0.77,0.78,0.78,0.78,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.85,0.85},
	{0.0750,0.10,0.11,0.12,0.13,0.15,0.19,0.24,0.29,0.34,0.36,0.39,0.41,0.44,0.45,0.49,0.50,0.52,0.54,0.57,0.58,0.59,0.61,0.63,0.63,0.65,0.66,0.67,0.68,0.69,0.69,0.69,0.71,0.72,0.73,0.73,0.74,0.74,0.75,0.76,0.76,0.77,0.77,0.77,0.78,0.78,0.78,0.79,0.80,0.80,0.80,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85},
	{0.0800,0.10,0.10,0.12,0.13,0.14,0.19,0.23,0.29,0.34,0.35,0.38,0.40,0.44,0.45,0.49,0.50,0.52,0.53,0.57,0.58,0.59,0.61,0.62,0.62,0.65,0.66,0.67,0.68,0.69,0.69,0.69,0.71,0.72,0.73,0.73,0.74,0.74,0.75,0.76,0.76,0.76,0.77,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.82,0.82,0.82,0.83,0.83,0.84,0.84,0.84,0.84,0.84,0.85},
	{0.0850,0.10,0.10,0.11,0.12,0.14,0.18,0.23,0.28,0.33,0.35,0.38,0.40,0.44,0.45,0.49,0.50,0.51,0.53,0.57,0.58,0.59,0.61,0.62,0.62,0.65,0.66,0.67,0.68,0.68,0.69,0.69,0.71,0.72,0.73,0.73,0.74,0.74,0.75,0.76,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.82,0.82,0.82,0.83,0.83,0.83,0.83,0.83,0.84,0.84,0.85},
	{0.0900,0.09,0.09,0.11,0.12,0.13,0.18,0.22,0.28,0.33,0.35,0.38,0.40,0.43,0.45,0.49,0.50,0.51,0.53,0.56,0.58,0.59,0.61,0.62,0.62,0.65,0.66,0.66,0.67,0.67,0.69,0.69,0.71,0.71,0.73,0.73,0.73,0.74,0.75,0.76,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.83,0.83,0.84,0.84,0.85},
	{0.0950,0.09,0.09,0.10,0.11,0.13,0.18,0.22,0.28,0.33,0.34,0.38,0.40,0.43,0.45,0.48,0.49,0.51,0.53,0.56,0.57,0.59,0.61,0.62,0.62,0.65,0.65,0.66,0.67,0.67,0.68,0.69,0.71,0.71,0.72,0.73,0.73,0.74,0.75,0.75,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.81,0.82,0.82,0.82,0.82,0.83,0.83,0.83,0.84,0.84,0.85},
	{0.1000,0.09,0.09,0.10,0.11,0.12,0.17,0.22,0.27,0.32,0.34,0.37,0.40,0.43,0.44,0.48,0.49,0.51,0.53,0.56,0.57,0.58,0.61,0.62,0.62,0.64,0.65,0.66,0.67,0.67,0.68,0.69,0.71,0.71,0.72,0.73,0.73,0.74,0.75,0.75,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.80,0.81,0.81,0.82,0.82,0.82,0.82,0.83,0.83,0.83,0.83,0.84,0.85},
	{0.1200,0.08,0.08,0.09,0.09,0.11,0.16,0.21,0.26,0.31,0.33,0.37,0.39,0.42,0.44,0.48,0.49,0.51,0.53,0.55,0.57,0.58,0.60,0.61,0.61,0.64,0.64,0.66,0.67,0.67,0.68,0.68,0.70,0.71,0.72,0.72,0.73,0.74,0.74,0.75,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.83,0.83,0.84,0.84},
	{0.1500,0.07,0.07,0.08,0.08,0.10,0.16,0.20,0.25,0.29,0.32,0.35,0.39,0.41,0.44,0.47,0.49,0.50,0.52,0.55,0.56,0.57,0.60,0.61,0.61,0.64,0.64,0.66,0.66,0.66,0.68,0.68,0.70,0.71,0.71,0.72,0.73,0.73,0.74,0.75,0.76,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.79,0.80,0.81,0.81,0.81,0.81,0.82,0.82,0.83,0.83,0.83,0.83,0.84,0.84},
	{0.2000,0.05,0.05,0.06,0.06,0.10,0.15,0.19,0.24,0.27,0.31,0.34,0.38,0.41,0.43,0.46,0.48,0.50,0.51,0.54,0.55,0.57,0.59,0.60,0.61,0.64,0.64,0.65,0.66,0.66,0.68,0.68,0.70,0.71,0.71,0.71,0.73,0.73,0.74,0.75,0.76,0.76,0.76,0.76,0.76,0.77,0.77,0.78,0.78,0.79,0.79,0.80,0.80,0.81,0.81,0.81,0.81,0.82,0.82,0.82,0.83,0.83,0.83,0.84},
	{0.2500,0.04,0.04,0.05,0.06,0.09,0.14,0.18,0.23,0.25,0.30,0.34,0.37,0.41,0.43,0.46,0.47,0.50,0.51,0.54,0.55,0.57,0.59,0.60,0.60,0.63,0.64,0.65,0.66,0.66,0.68,0.68,0.70,0.70,0.71,0.71,0.73,0.73,0.74,0.75,0.75,0.76,0.76,0.76,0.76,0.77,0.77,0.77,0.78,0.78,0.79,0.80,0.80,0.81,0.81,0.81,0.81,0.82,0.82,0.82,0.82,0.83,0.83,0.84},
	{0.2600,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00},
	{1.0000,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}
};
const double ratiotab10[31][41]={
	{0.000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000},
	{0.010,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000,1.000000000000000},
	{0.011,0.963491200335944,0.966249384900934,0.969007569465924,0.971383039236301,0.973229088258184,0.978095890159255,0.977731429398372,0.978631231117399,0.980135420330173,0.981639609542948,0.976134826675712,0.970630043808475,0.976178041414317,0.981726039020159,0.981077067137265,0.984189605519119,0.984204052316411,0.984218499113702,0.986827836688449,0.989437174263197,0.987438586233359,0.987560564739844,0.986885441239609,0.986210317739374,0.989070722238625,0.991931126737876,0.988041044406521,0.992168850442779,0.990190829323580,0.988212808204381,0.992010487752071,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761,0.995808167299761},
	{0.016,0.799834518089909,0.814897318267053,0.829960118444198,0.840602046001821,0.851455771038273,0.878147337289067,0.879956110123148,0.883680836783764,0.890501305718523,0.897321774653282,0.896902516388933,0.896483258124583,0.905352168960621,0.914221079796659,0.920351508678607,0.914068215107887,0.922086830254308,0.930105445400729,0.934166260135191,0.938227074869653,0.937814369227994,0.941460493312214,0.942173074208314,0.942885655104415,0.947571724002187,0.952257792899960,0.946288791355471,0.959092614938045,0.955329122483994,0.951565630029943,0.963514219609463,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983,0.975462809188983},
	{0.021,0.682403839076713,0.702794110603308,0.723184382129903,0.743458417965349,0.762062360229772,0.795145805819759,0.799862183900351,0.819123294988546,0.828905486097538,0.838687677206530,0.842390517340331,0.846093357474131,0.856554697979303,0.867016038484475,0.877877196432654,0.868191878005836,0.879280937396011,0.890369996786186,0.894923560466390,0.899477124146593,0.903261765317316,0.908915627635586,0.910909399636859,0.912903171638132,0.916129378449036,0.919355585259939,0.919612438013772,0.929611651002147,0.927652502675995,0.925693354349844,0.939887424559090,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336,0.954081494768336},
	{0.026,0.587935282619425,0.613949617918180,0.639963953216935,0.672084178256469,0.700442247425954,0.729659459675582,0.740503527756466,0.775035027127189,0.787331303466935,0.799627579806680,0.802444389153373,0.805261198500066,0.820221474929404,0.835181751358742,0.844573692555534,0.843932723234161,0.854626724997418,0.865320726760674,0.870383521867956,0.875446316975238,0.881110391822826,0.884125738380003,0.887899987329420,0.891674236278838,0.895261141574959,0.898848046871081,0.898181709568404,0.905473402769580,0.906163145402374,0.906852888035168,0.919687264598260,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353,0.932521641161353},
	{0.031,0.519773260681670,0.551371019658023,0.582968778634377,0.615361582574098,0.649984636405883,0.679413551149778,0.700577642698429,0.742233066480311,0.755640802233977,0.769048537987642,0.772323384868829,0.775598231750015,0.792765999939808,0.809933768129601,0.818844285163575,0.826328256599546,0.835123873148331,0.843919489697117,0.849407143235454,0.854894796773792,0.862153050339075,0.866699873741486,0.871139186311405,0.875578498881324,0.878991061530502,0.882403624179680,0.882067826961624,0.889031863193269,0.890982654671049,0.892933446148828,0.902592084007499,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170,0.912250721866170},
	{0.036,0.478452649076062,0.508607657766473,0.538762666456884,0.570700091316174,0.599301555288813,0.642769374682529,0.669324812551509,0.714520159036086,0.729005121962147,0.743490084888208,0.749028786024466,0.754567487160724,0.772107740130707,0.789647993100691,0.797275641569254,0.809436001112007,0.817593981077019,0.825751961042032,0.831570230449729,0.837388499857427,0.845866854428079,0.852682743773999,0.857701220706990,0.862719697639981,0.865344722979260,0.867969748318539,0.869550946291171,0.876688180654993,0.879566720908531,0.882445261162069,0.888590735771496,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923,0.894736210380923},
	{0.041,0.439153300197896,0.471545249830515,0.503937199463135,0.533702160071396,0.553522052653414,0.610878093320771,0.643365584888650,0.689384938709345,0.704581402387785,0.719777866066225,0.727681680506933,0.735585494947641,0.754247875239092,0.772910255530543,0.778726103871341,0.794129700277637,0.802266758259786,0.810403816241936,0.816511562085667,0.822619307929398,0.831884425835156,0.840815937036500,0.846210398617678,0.851604860198857,0.853532493450197,0.855460126701537,0.858812788421333,0.866980243097433,0.870621283149484,0.874262323201536,0.877853951702640,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744,0.881445580203744},
	{0.046,0.410977357058603,0.443058857177702,0.475140357296802,0.502395321718132,0.522273447868833,0.583071622700397,0.620070771338617,0.666853295670156,0.682057073891411,0.697260852112667,0.707519155680551,0.717777459248435,0.737810592377061,0.757843725505687,0.763401755570305,0.780163291781344,0.788812011262346,0.797460730743348,0.803869916718153,0.810279102692958,0.819838386305624,0.830946793664087,0.836472637509304,0.841998481354520,0.843393474048537,0.844788466742553,0.849490778339224,0.859713079009327,0.863226116075273,0.866739153141220,0.869989321742431,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642,0.873239490343642},
	{0.051,0.387971591423495,0.418675963453983,0.449380335484472,0.475447806446167,0.495978759130784,0.558929294174387,0.599050116724223,0.646951120088588,0.661742393441799,0.676533666795010,0.689487686728806,0.702441706662602,0.723296206827663,0.744150706992724,0.750733167677884,0.767196918848323,0.776839529107835,0.786482139367346,0.793270952609354,0.800059765851362,0.809361357584799,0.822922653791860,0.828346401059276,0.833770148326692,0.834819312091080,0.835868475855468,0.841222341031958,0.853685890579306,0.856700972443389,0.859716054307471,0.863172491720689,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908,0.866628929133908},
	{0.056,0.367338191151950,0.396898836742794,0.426459482333639,0.451534684386553,0.473407370856251,0.538030439095726,0.580322043914358,0.629704302134707,0.643950963169807,0.658197624204906,0.673597134080021,0.688996643955136,0.710422457499994,0.731848271044853,0.739386994687664,0.756135022321118,0.766538383086710,0.776941743852303,0.784246804212366,0.791551864572428,0.800093158774863,0.816558240430922,0.821592157269947,0.826626074108973,0.827619967781566,0.828613861454160,0.833655206946714,0.847967469854480,0.850582741011772,0.853198012169064,0.856975869620154,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244,0.860753727071244},
	{0.061,0.349209299042099,0.377711277002395,0.406213254962691,0.430254048516241,0.453510606303724,0.519938988832050,0.563904975777914,0.615138731978583,0.628996385206296,0.642854038434009,0.659803462054019,0.676752885674030,0.698853187194652,0.720953488715274,0.729373217717933,0.746942138237975,0.757758204440588,0.768574270643201,0.776305474270307,0.784036677897413,0.791834186062164,0.810874815178426,0.815399010375731,0.819923205573036,0.821427295710182,0.822931385847327,0.826741487688408,0.842565247263279,0.844877629729026,0.847190012194772,0.851376300141292,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812,0.855562588087812},
	{0.066,0.333717057892076,0.361097084191047,0.388477110490018,0.411766870083778,0.435244913987108,0.504161147882095,0.549800117547504,0.602992894634689,0.617048559104329,0.631104223573969,0.648300646148099,0.665497068722229,0.688490249889708,0.711483431057186,0.720711144635293,0.738004473564393,0.749581268707437,0.761158063850481,0.769268233712056,0.777378403573631,0.784542697732669,0.805469535867187,0.809549249762833,0.813628963658480,0.815868749651907,0.818108535645333,0.820761991790077,0.837486653234135,0.839591846543751,0.841697039853368,0.846350627984571,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773,0.851004216115773},
	{0.071,0.320934035938600,0.347013513580530,0.373092991222459,0.396234406271788,0.418195763660312,0.490222344676145,0.536952165367634,0.592322696979099,0.607222947841078,0.622123198703057,0.638571904706009,0.655020610708960,0.679237889916375,0.703455169123790,0.713056114170666,0.729428465121532,0.741949966353056,0.754471467584580,0.762996078406179,0.771520689227779,0.778183606396762,0.800337588512759,0.804051487572793,0.807765386632828,0.810730768413047,0.813696150193267,0.816003454929185,0.832739118195478,0.834731599404552,0.836724080613627,0.841875697850458,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288,0.847027315087288},
	{0.076,0.310017589565652,0.335035365260396,0.360053140955140,0.383429375517089,0.402767767659704,0.477650794299476,0.524771041044218,0.582836208081616,0.598303919390869,0.613771630700121,0.629569601831247,0.645367572962373,0.670915200420828,0.696462827879284,0.705871937976223,0.721320549730555,0.734806687843247,0.748292825955938,0.757350004221244,0.766407182486550,0.772721824664826,0.795474159130695,0.798914335947150,0.802354512763604,0.806012305874787,0.809670098985969,0.812025196055920,0.828330072575740,0.830303096260030,0.832276119944321,0.837928354439420,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520,0.843580588934520},
	{0.081,0.300268142191808,0.324536176770675,0.348804211349542,0.372303945137858,0.389350938840071,0.465974213575084,0.513315739758856,0.574291728591041,0.590136714446206,0.605981700301372,0.621397709647954,0.636813718994535,0.663340039515583,0.689866360036630,0.699151936605003,0.713787164212623,0.728088401347479,0.742389638482335,0.752185584729488,0.761981530976642,0.768054503456218,0.790874433736551,0.794146407027442,0.797418380318334,0.801712315918309,0.806006251518284,0.808434389341544,0.824266946803352,0.826312545058788,0.828358143314225,0.834485442451926,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628,0.840612741589628},
	{0.086,0.291241186498409,0.314899994695977,0.338558802893546,0.362090300972286,0.378278380900962,0.454746351634601,0.502645256693150,0.566447559156173,0.582583756889110,0.598719954622047,0.613912192989017,0.629104431355986,0.656377821557495,0.683651211759003,0.692894583292676,0.706934745388898,0.721799669224881,0.736664593060864,0.747425987692806,0.758187382324749,0.763713558930053,0.786533598345880,0.789756312955211,0.792979027564541,0.797829752424797,0.802680477285053,0.805209073573047,0.820557171306744,0.822766153749428,0.824975136192111,0.831523806588443,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775,0.838072476984775},
	{0.091,0.282492215166800,0.305510865620917,0.328529516075034,0.352826652585663,0.368523523618512,0.443936636053523,0.492818587028700,0.559062000425812,0.575507470601599,0.591952940777386,0.606957447301865,0.621961953826343,0.649885706254695,0.677809458683047,0.687098351274911,0.700869730080540,0.716048191947459,0.731226653814377,0.743005335049631,0.754784016284884,0.759629088556047,0.782446838974238,0.785752665871994,0.789058492769751,0.794363569275434,0.799668645781118,0.802327287537421,0.817208176514350,0.819601979918782,0.821995783323213,0.828942336121590,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966,0.835888888919966},
	{0.096,0.273578683628321,0.295764021129764,0.317949358631207,0.344138009551642,0.359513557641176,0.433663581782394,0.483894725947109,0.551893353048760,0.568770279465694,0.585647205882628,0.600839075657221,0.616030945431815,0.644182060938610,0.672333176445405,0.681761713787378,0.695698555108713,0.710945909433201,0.726193263757688,0.738843214786145,0.751493165814601,0.755816755661850,0.778609341637178,0.782142790559095,0.785676239481011,0.791311432991167,0.796946626501323,0.799767070021656,0.814227392854598,0.816710203583027,0.819193014311455,0.826523416403040,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625,0.833853818494625},
	{0.120,0.229389024389659,0.249709162277695,0.270029300165731,0.298936271035947,0.324141841248556,0.395406617759563,0.454092063489711,0.518294233007547,0.539519704478992,0.560745175950438,0.580136833502892,0.599528491055345,0.625206418658382,0.650884346261419,0.662152082846232,0.681179988805059,0.695789161313353,0.710398333821647,0.723851668516087,0.737305003210528,0.741799920802634,0.763507191103449,0.768417331102059,0.773327471100670,0.780242513989087,0.787157556877504,0.790693609414450,0.805125587029775,0.806921100999125,0.808716614968474,0.817071444573460,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446,0.825426274178446},
	{0.150,0.173562359966580,0.202681757515059,0.231801155063537,0.259524052016889,0.289308420504610,0.365759358475685,0.429547976433182,0.485952221260085,0.511897641140634,0.537843061021182,0.562084811274067,0.586326561526952,0.610040827745228,0.633755093963505,0.649717296033923,0.669630086505765,0.685027828029847,0.700425569553929,0.712003951971866,0.723582334389802,0.732664532417658,0.751736570090760,0.757583445954525,0.763430321818289,0.771830979876554,0.780231637934820,0.785032960620061,0.798468567957013,0.800813558434465,0.803158548911918,0.810330349337498,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079,0.817502149763079},
	{0.200,0.098646159811201,0.139188186596497,0.179730213381794,0.218066835281035,0.258066397636293,0.328311865788127,0.401327050400633,0.449893720904585,0.479914299331182,0.509934877757778,0.538986868119549,0.568038858481320,0.592103064775846,0.616167271070373,0.636934646859539,0.657373740531470,0.672509126913012,0.687644513294554,0.699517791221936,0.711391069149318,0.723448767064611,0.741690591055204,0.747539496956774,0.753388402858344,0.763118603565479,0.772848804272614,0.779744972226447,0.790386333863852,0.794319706774836,0.798253079685820,0.803385818737456,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092,0.808518557789092},
	{0.250,0.039397595392429,0.090884821980010,0.142372048567591,0.187303739412184,0.235482769312622,0.297355057634163,0.379075846260951,0.420944708707290,0.455461279039084,0.489977849370878,0.521745285053071,0.553512720735263,0.579854619716696,0.606196518698129,0.628321672395608,0.647585630914837,0.662109118968355,0.676632607021873,0.690891060973797,0.705149514925720,0.717318747136481,0.730459123110750,0.738946552159138,0.747433981207526,0.757753403507850,0.768072825808174,0.774938437966424,0.785126593182027,0.789414999424253,0.793703405666479,0.797505224071355,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231,0.801307042476231},
	{0.300,0.021047896775840,0.071108464730964,0.121169032686088,0.168885601821729,0.213578615769714,0.273066769541076,0.360776713761819,0.397796340556935,0.436275357638552,0.474754374720170,0.508978234444980,0.543202094169790,0.571052544860864,0.598902995551939,0.621483703920921,0.639596213151800,0.654464408015884,0.669332602879968,0.685237723031466,0.701142843182965,0.712181193231773,0.720165628630026,0.731491090798414,0.742816552966801,0.753436797651763,0.764057042336725,0.770719259487742,0.781599452361292,0.785756942085925,0.789914431810557,0.792673232457936,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314,0.795432033105314},
	{0.350,0.011333453127035,0.059986957573989,0.108640462020944,0.153858351505968,0.197134866866849,0.254128041438510,0.345933076833691,0.383111296841587,0.424261648660219,0.465412000478850,0.501035934237959,0.536659867997067,0.564812061392058,0.592964254787048,0.616440276133522,0.634038661861171,0.648967864067922,0.663897066274672,0.681364470282165,0.698831874289658,0.708394342114359,0.714701416421282,0.726996298778046,0.739291181134810,0.750168466609966,0.761045752085122,0.766802538389465,0.778687903453508,0.783005018625862,0.787322133798216,0.789902523208237,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258,0.792482912618258},
	{0.400,0.011247874429524,0.055474815439150,0.099701756448776,0.142545648016812,0.184848902312135,0.238989925797447,0.334092145202051,0.372104890767172,0.415345134992871,0.458585379218571,0.495023650880262,0.531461922541953,0.559332720726316,0.587203518910679,0.612921717342923,0.631412804962197,0.645364271104707,0.659315737247217,0.678191260437401,0.697066783627585,0.706813087505316,0.713902267886003,0.725255062022776,0.736607856159550,0.747945554719885,0.759283253280220,0.765658595196935,0.776538052448838,0.781012483765834,0.785486915082831,0.788935510521548,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265},
	{0.450,0.011116753351296,0.051975294131752,0.092833834912208,0.133734915349141,0.175111358969462,0.229110255576304,0.324542080015660,0.361342881919184,0.408567953576111,0.455793025233039,0.491373441367330,0.526953857501621,0.554368741354233,0.581783625206846,0.610135546372381,0.629818279298919,0.642984846944189,0.656151414589460,0.675988239906460,0.695825065223460,0.705735293531639,0.713417123491555,0.723952364835309,0.734487606179063,0.746419630736170,0.758351655293277,0.765098505695621,0.775827814569536,0.779949924134941,0.784072033700346,0.788228069830306,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265},
	{0.499,0.008634378729724,0.048368378231148,0.088102377732572,0.127850677384214,0.167679265660954,0.223152099046353,0.316164798107462,0.356953642384106,0.405960288265639,0.454966934147172,0.488818368511146,0.522669802875119,0.549890578470502,0.577111354065883,0.608625286574539,0.628500614778987,0.641734079974500,0.654967545170013,0.675165897945868,0.695364250721722,0.705299898992211,0.713245125454679,0.723189071801203,0.733133018147727,0.745540029684902,0.757947041222077,0.764900768115986,0.775827814569536,0.779637153658045,0.783446492746553,0.787915299353409,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265,0.792384105960265},
	{0.500,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000},
	{1.000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000,0.000000000000000}
};
const double lam_carr[MAXFREQ]={ /* carrier wave length (m) */
    CLIGHT/FREQ1,CLIGHT/FREQ2,CLIGHT/FREQ5,CLIGHT/FREQ6,CLIGHT/FREQ7,
    CLIGHT/FREQ8,CLIGHT/FREQ9
};
const prcopt_t prcopt_default={      /* defaults processing options */
    0,                               /* [Initial], s */
    1,                               /* [estm], s */
    {0},                             /* [exsats] excluded satellites (1:excluded,2:included) */
    0,                               /* [ratio] */
    SYS_GPS,                         /* [navsys] 1:gps+2:sbas+4:glo+8:gal+16:qzs+32:comp */
    0,                               /* [sateph] 0:brdc,1:precise */
    4,                               /* [estion   0:not est(prec) 0:off,1:brdc,2:sbas,3:dual-freq,4:est-stec */
    0,                               /* [esttrop] 0:off,1:saas,2:sbas,3:est-ztd,4:est-ztdgrad,5:ztd */
    2,2,                             /* [rovpos/refpos 0: moving base 2: static base] */
    10.0 * D2R,                      /* [elmin] */
    {100.0,100.0},                   /* eratio[] */
    {100.0,0.003,0.003,0.0,1},       /* err[] */
    {30.0,0.03,0.3},                 /* std[] */
    {0.0,10,1E-4,1E+2,1E+2,0.2},     /* [prn[]] process-noise std [0]bias,[1]iono [2]trop [3]acch [4]accv [5] pos */
    5E-12,                           /* sclkstab */
    0.05,                            /* thresslip */
    30.0,30.0,                       /* maxtdif,maxinno */
    {{0}},                           /* [antdel] antenna delta {e,n,u} */
    {{0,0}},                         /* [snrmask] */
    2,                               /* [nf] */
    0,                               /*0:forward*/
    0,                               /*0:single process 1:continue process*/
    "",                              /* Station Name */
    0,                               /* 0:use bds3 1:use bds2 */
    ""                               /* DOY date */
};
const solopt_t solopt_default={ /* defaults solution output options */
    SOLF_XYZ,                   /* [posf] 1:xyz */
    TIMES_GPST,1,2,             /* [times],[timef],[timeu] */
    0,                          /* [degf] (0:deg,1:dms) */
    1,                          /* [outhead] output header (0:no,1:yes) */
    0,                          /* [datum] datum (0:WGS84,1:Tokyo) */
    1,                          /* [height] height (0:ellipsoidal,1:geodetic) */
    0,                          /* [geoid] geoid model (0:internal,1:egm96,2:egm08_2.5,3:egm08_1,4:gsi2000) */
    0,                          /* [solstatic] solution of static mode (0:all,1:single) */
    0,                          /* [sstat] solution statistics level (0:off,1:states,2:residuals) */
    " ","",                     /* [separator]/[program name] */
    0                           /* [maxsolstd] max std-dev for solution output (m) (0:all) */
};
const char *statestrs[32]={    /* stream format strings */
    "_SINGLE",       /*  0 */
    "_DGPS",         /*  1 */
    "_KINEMA",       /*  2 */
    "_STATIC",       /*  3 */
    "_MOVEB",        /*  4 */
    "_FIXED",        /*  5 */
    "_PPP_KINEMA",   /*  6 */
    "_PPP_STATIC",   /*  7 */
    "_PPP_FIXED",    /*  8 */
    "_INS_UPDATE",   /*  9 */
    "_INS_LGNSS",    /*  10 */
    "_INS_TGNSS",    /*  11 */
    "_INS_LVO",      /*  12 */
    "_VO",           /*  13 */
    NULL
};
const char *formatstrs[32]={    /* stream format strings */
    "RTCM 2",                   /*  0 */
    "RTCM 3",                   /*  1 */
    "NovAtel OEM6",             /*  2 */
    "NovAtel OEM3",             /*  3 */
    "u-blox",                   /*  4 */
    "Superstar II",             /*  5 */
    "Hemisphere",               /*  6 */
    "SkyTraq",                  /*  7 */
    "GW10",                     /*  8 */
    "Javad",                    /*  9 */
    "NVS BINR",                 /* 10 */
    "BINEX",                    /* 11 */
    "Trimble RT17",             /* 12 */
    "Septentrio",               /* 13 */
    "CMR/CMR+",                 /* 14 */
    "TERSUS",                   /* 15 */
    "LEX Receiver",             /* 16 */
    "RINEX",                    /* 17 */
    "SP3",                      /* 18 */
    "RINEX CLK",                /* 19 */
    "SBAS",                     /* 20 */
    "NMEA 0183",                /* 21 */
    NULL
};
static const char* obscodes[] = {       /* observation code strings */
    ""  ,"1C","1P","1W","1Y", "1M","1N","1S","1L","1E", /*  0- 9 */
    "1A","1B","1X","1Z","2C", "2D","2S","2L","2X","2P", /* 10-19 */
    "2W","2Y","2M","2N","5I", "5Q","5X","7I","7Q","7X", /* 20-29 */
    "6A","6B","6C","6X","6Z", "6S","6L","8L","8Q","8X", /* 30-39 */
    "2I","2Q","6I","6Q","3I", "3Q","3X","1I","1Q","5A", /* 40-49 */
    "5B","5C","9A","9B","9C", "9X","1D","5D","5P","7D", /* 50-59 */
    "7P","7Z","8D","8P","8I", "5Z","6E",""  ,""  ,""    /* 60-69 */
};
static unsigned char obsfreqs[]={
    0, 1, 1, 1, 1,  1, 1, 1, 1, 1, /*  0- 9 */
    1, 1, 1, 1, 2,  2, 2, 2, 2, 2, /* 10-19 */
    2, 2, 2, 2, 3,  3, 3, 5, 5, 5, /* 20-29 */
    4, 4, 4, 4, 4,  4, 4, 6, 6, 6, /* 30-39 */
    2, 2, 4, 4, 3,  3, 3, 1, 1, 3, /* 40-49 */
    3, 3, 7, 7, 7,  7, 1, 3, 3, 7, /* 50-59 */
	7, 7, 6, 6, 6,  3, 4, 0, 0, 0  /* 60-69 */
};
static char codepris[7][MAXFREQ][16]={  /* code priority table */
    /* L1/E1/B1    L2/(B1-2)       B2a/L5/E5a/L3  E6/L6/LEX/B3  E5b/B2b-2  E5(a+b)   B2b-3/S */
     {"CPYWMNSL"    ,"PYXWCMNDSL"     ,"IQX"       ,""         ,""         ,""      ,""    }, /* GPS 1*/
     {"PC"          ,"PC"             ,""          ,""         ,""         ,""      ,""    }, /* GLO */
     {"CX"          ,""               ,"IQX"       ,"ABCXZ"    ,"IQX"      ,"IQX"   ,""    }, /* GAL 1*/
     {"CSLXZ"       ,"SLX"            ,"IQX"       ,""         ,""         ,""      ,""    }, /* QZS 1*/
     {" "           ,""               ,""          ,""         ,""         ,""      ,""    }, /* SBS */
     {"PXIQ "       ,"IQX"            ,"PXIQ"      ,"IQX"      ,"IQX"      ,"XPD"   ,"D"   }, /* BDS 1*/
     {""            ,""               ,""          ,""         ,""         ,""      ,""    }  /* IRN */
};
static fatalfunc_t *fatalfunc=NULL; /* fatal callback function */

/* crc tables generated by util/gencrc ---------------------------------------*/
static const unsigned short tbl_CRC16[]={
    0x0000,0x1021,0x2042,0x3063,0x4084,0x50A5,0x60C6,0x70E7,
    0x8108,0x9129,0xA14A,0xB16B,0xC18C,0xD1AD,0xE1CE,0xF1EF,
    0x1231,0x0210,0x3273,0x2252,0x52B5,0x4294,0x72F7,0x62D6,
    0x9339,0x8318,0xB37B,0xA35A,0xD3BD,0xC39C,0xF3FF,0xE3DE,
    0x2462,0x3443,0x0420,0x1401,0x64E6,0x74C7,0x44A4,0x5485,
    0xA56A,0xB54B,0x8528,0x9509,0xE5EE,0xF5CF,0xC5AC,0xD58D,
    0x3653,0x2672,0x1611,0x0630,0x76D7,0x66F6,0x5695,0x46B4,
    0xB75B,0xA77A,0x9719,0x8738,0xF7DF,0xE7FE,0xD79D,0xC7BC,
    0x48C4,0x58E5,0x6886,0x78A7,0x0840,0x1861,0x2802,0x3823,
    0xC9CC,0xD9ED,0xE98E,0xF9AF,0x8948,0x9969,0xA90A,0xB92B,
    0x5AF5,0x4AD4,0x7AB7,0x6A96,0x1A71,0x0A50,0x3A33,0x2A12,
    0xDBFD,0xCBDC,0xFBBF,0xEB9E,0x9B79,0x8B58,0xBB3B,0xAB1A,
    0x6CA6,0x7C87,0x4CE4,0x5CC5,0x2C22,0x3C03,0x0C60,0x1C41,
    0xEDAE,0xFD8F,0xCDEC,0xDDCD,0xAD2A,0xBD0B,0x8D68,0x9D49,
    0x7E97,0x6EB6,0x5ED5,0x4EF4,0x3E13,0x2E32,0x1E51,0x0E70,
    0xFF9F,0xEFBE,0xDFDD,0xCFFC,0xBF1B,0xAF3A,0x9F59,0x8F78,
    0x9188,0x81A9,0xB1CA,0xA1EB,0xD10C,0xC12D,0xF14E,0xE16F,
    0x1080,0x00A1,0x30C2,0x20E3,0x5004,0x4025,0x7046,0x6067,
    0x83B9,0x9398,0xA3FB,0xB3DA,0xC33D,0xD31C,0xE37F,0xF35E,
    0x02B1,0x1290,0x22F3,0x32D2,0x4235,0x5214,0x6277,0x7256,
    0xB5EA,0xA5CB,0x95A8,0x8589,0xF56E,0xE54F,0xD52C,0xC50D,
    0x34E2,0x24C3,0x14A0,0x0481,0x7466,0x6447,0x5424,0x4405,
    0xA7DB,0xB7FA,0x8799,0x97B8,0xE75F,0xF77E,0xC71D,0xD73C,
    0x26D3,0x36F2,0x0691,0x16B0,0x6657,0x7676,0x4615,0x5634,
    0xD94C,0xC96D,0xF90E,0xE92F,0x99C8,0x89E9,0xB98A,0xA9AB,
    0x5844,0x4865,0x7806,0x6827,0x18C0,0x08E1,0x3882,0x28A3,
    0xCB7D,0xDB5C,0xEB3F,0xFB1E,0x8BF9,0x9BD8,0xABBB,0xBB9A,
    0x4A75,0x5A54,0x6A37,0x7A16,0x0AF1,0x1AD0,0x2AB3,0x3A92,
    0xFD2E,0xED0F,0xDD6C,0xCD4D,0xBDAA,0xAD8B,0x9DE8,0x8DC9,
    0x7C26,0x6C07,0x5C64,0x4C45,0x3CA2,0x2C83,0x1CE0,0x0CC1,
    0xEF1F,0xFF3E,0xCF5D,0xDF7C,0xAF9B,0xBFBA,0x8FD9,0x9FF8,
    0x6E17,0x7E36,0x4E55,0x5E74,0x2E93,0x3EB2,0x0ED1,0x1EF0
};
static const unsigned int tbl_CRC24Q[]={
    0x000000,0x864CFB,0x8AD50D,0x0C99F6,0x93E6E1,0x15AA1A,0x1933EC,0x9F7F17,
    0xA18139,0x27CDC2,0x2B5434,0xAD18CF,0x3267D8,0xB42B23,0xB8B2D5,0x3EFE2E,
    0xC54E89,0x430272,0x4F9B84,0xC9D77F,0x56A868,0xD0E493,0xDC7D65,0x5A319E,
    0x64CFB0,0xE2834B,0xEE1ABD,0x685646,0xF72951,0x7165AA,0x7DFC5C,0xFBB0A7,
    0x0CD1E9,0x8A9D12,0x8604E4,0x00481F,0x9F3708,0x197BF3,0x15E205,0x93AEFE,
    0xAD50D0,0x2B1C2B,0x2785DD,0xA1C926,0x3EB631,0xB8FACA,0xB4633C,0x322FC7,
    0xC99F60,0x4FD39B,0x434A6D,0xC50696,0x5A7981,0xDC357A,0xD0AC8C,0x56E077,
    0x681E59,0xEE52A2,0xE2CB54,0x6487AF,0xFBF8B8,0x7DB443,0x712DB5,0xF7614E,
    0x19A3D2,0x9FEF29,0x9376DF,0x153A24,0x8A4533,0x0C09C8,0x00903E,0x86DCC5,
    0xB822EB,0x3E6E10,0x32F7E6,0xB4BB1D,0x2BC40A,0xAD88F1,0xA11107,0x275DFC,
    0xDCED5B,0x5AA1A0,0x563856,0xD074AD,0x4F0BBA,0xC94741,0xC5DEB7,0x43924C,
    0x7D6C62,0xFB2099,0xF7B96F,0x71F594,0xEE8A83,0x68C678,0x645F8E,0xE21375,
    0x15723B,0x933EC0,0x9FA736,0x19EBCD,0x8694DA,0x00D821,0x0C41D7,0x8A0D2C,
    0xB4F302,0x32BFF9,0x3E260F,0xB86AF4,0x2715E3,0xA15918,0xADC0EE,0x2B8C15,
    0xD03CB2,0x567049,0x5AE9BF,0xDCA544,0x43DA53,0xC596A8,0xC90F5E,0x4F43A5,
    0x71BD8B,0xF7F170,0xFB6886,0x7D247D,0xE25B6A,0x641791,0x688E67,0xEEC29C,
    0x3347A4,0xB50B5F,0xB992A9,0x3FDE52,0xA0A145,0x26EDBE,0x2A7448,0xAC38B3,
    0x92C69D,0x148A66,0x181390,0x9E5F6B,0x01207C,0x876C87,0x8BF571,0x0DB98A,
    0xF6092D,0x7045D6,0x7CDC20,0xFA90DB,0x65EFCC,0xE3A337,0xEF3AC1,0x69763A,
    0x578814,0xD1C4EF,0xDD5D19,0x5B11E2,0xC46EF5,0x42220E,0x4EBBF8,0xC8F703,
    0x3F964D,0xB9DAB6,0xB54340,0x330FBB,0xAC70AC,0x2A3C57,0x26A5A1,0xA0E95A,
    0x9E1774,0x185B8F,0x14C279,0x928E82,0x0DF195,0x8BBD6E,0x872498,0x016863,
    0xFAD8C4,0x7C943F,0x700DC9,0xF64132,0x693E25,0xEF72DE,0xE3EB28,0x65A7D3,
    0x5B59FD,0xDD1506,0xD18CF0,0x57C00B,0xC8BF1C,0x4EF3E7,0x426A11,0xC426EA,
    0x2AE476,0xACA88D,0xA0317B,0x267D80,0xB90297,0x3F4E6C,0x33D79A,0xB59B61,
    0x8B654F,0x0D29B4,0x01B042,0x87FCB9,0x1883AE,0x9ECF55,0x9256A3,0x141A58,
    0xEFAAFF,0x69E604,0x657FF2,0xE33309,0x7C4C1E,0xFA00E5,0xF69913,0x70D5E8,
    0x4E2BC6,0xC8673D,0xC4FECB,0x42B230,0xDDCD27,0x5B81DC,0x57182A,0xD154D1,
    0x26359F,0xA07964,0xACE092,0x2AAC69,0xB5D37E,0x339F85,0x3F0673,0xB94A88,
    0x87B4A6,0x01F85D,0x0D61AB,0x8B2D50,0x145247,0x921EBC,0x9E874A,0x18CBB1,
    0xE37B16,0x6537ED,0x69AE1B,0xEFE2E0,0x709DF7,0xF6D10C,0xFA48FA,0x7C0401,
    0x42FA2F,0xC4B6D4,0xC82F22,0x4E63D9,0xD11CCE,0x575035,0x5BC9C3,0xDD8538
};
/* function prototypes -------------------------------------------------------*/
#ifdef MKL
#define LAPACK
#define dgemm_  dgemm
#define dgetrf_ dgetrf
#define dgetri_ dgetri
#define dgetrs_ dgetrs
#endif
#ifdef LAPACK
extern void dgemm_ (char *,char *,int *,int *,int *,double *,double *,int *,double *,int *,double *,double *,int *);
extern void dgetrf_(int *,int *,double *,int *,int *,int *);
extern void dgetri_(int *,double *,int *,int *,double *,int *,int *);
extern void dgetrs_(char *,int *,int *,double *,int *,int *,double *,int *,int *);
#endif

/* fatal error */
static void fatalerr(const char *format, ...)
{
    char msg[1024];
    va_list ap;
    va_start(ap,format); vsprintf(msg,format,ap); va_end(ap);
    if (fatalfunc) fatalfunc(msg);
    else fprintf(stderr,"%s",msg);
    exit(-9);
}


/* satellite system+prn/slot number to satellite number */
extern int satno(int sys, int prn)
{
    if (prn<=0) return 0;
    switch (sys) {
        case SYS_GPS:
            if (prn<MINPRNGPS||MAXPRNGPS<prn) return 0;
            return prn-MINPRNGPS+1;
        case SYS_GLO:
            if (prn<MINPRNGLO||MAXPRNGLO<prn) return 0;
            return NSATGPS+prn-MINPRNGLO+1;
        case SYS_GAL:
            if (prn<MINPRNGAL||MAXPRNGAL<prn) return 0;
            return NSATGPS+NSATGLO+prn-MINPRNGAL+1;
        case SYS_QZS:
            if (prn<MINPRNQZS||MAXPRNQZS<prn) return 0;
            return NSATGPS+NSATGLO+NSATGAL+prn-MINPRNQZS+1;
        case SYS_CMP:
            if (prn<MINPRNCMP||MAXPRNCMP<prn) return 0;
            return NSATGPS+NSATGLO+NSATGAL+NSATQZS+prn-MINPRNCMP+1;
        case SYS_IRN:
            if (prn<MINPRNIRN||MAXPRNIRN<prn) return 0;
            return NSATGPS+NSATGLO+NSATGAL+NSATQZS+NSATCMP+prn-MINPRNIRN+1;
        case SYS_LEO:
            if (prn<MINPRNLEO||MAXPRNLEO<prn) return 0;
            return NSATGPS+NSATGLO+NSATGAL+NSATQZS+NSATCMP+NSATIRN+
                   prn-MINPRNLEO+1;
    }
    return 0;
}
/* satellite number to satellite system ----------------------------------------
* convert satellite number to satellite system
* args   : int    sat       I   satellite number (1-MAXSAT)
*          int    *prn      IO  satellite prn/slot number (NULL: no output)
* return : satellite system (SYS_GPS,SYS_GLO,...)
*-----------------------------------------------------------------------------*/
extern int satsys(int sat, int *prn)
{
    int sys=SYS_NONE;
    if (sat<=0||MAXSAT<sat) sat=0;
    else if (sat<=NSATGPS) {
        sys=SYS_GPS; sat+=MINPRNGPS-1;
    }
    else if ((sat-=NSATGPS)<=NSATGLO) {
        sys=SYS_GLO; sat+=MINPRNGLO-1;
    }
    else if ((sat-=NSATGLO)<=NSATGAL) {
        sys=SYS_GAL; sat+=MINPRNGAL-1;
    }
    else if ((sat-=NSATGAL)<=NSATQZS) {
        sys=SYS_QZS; sat+=MINPRNQZS-1;
    }
    else if ((sat-=NSATQZS)<=NSATCMP) {
        sys=SYS_CMP; sat+=MINPRNCMP-1;
    }
    else if ((sat-=NSATCMP)<=NSATIRN) {
        sys=SYS_IRN; sat+=MINPRNIRN-1;
    }
    else if ((sat-=NSATIRN)<=NSATLEO) {
        sys=SYS_LEO; sat+=MINPRNLEO-1;
    }
    else sat=0;
    if (prn) *prn=sat;
    return sys;
}
extern int num2sys(int nsys)
{
    if (nsys<=0||NSYS<nsys)            return SYS_NONE;
    else if ( nsys          <=NSYSGPS) return SYS_GPS;
    else if ((nsys-=NSYSGPS)<=NSYSGLO) return SYS_GLO;
    else if ((nsys-=NSYSGLO)<=NSYSGAL) return SYS_GAL;
    else if ((nsys-=NSYSGAL)<=NSYSQZS) return SYS_QZS;
    else if ((nsys-=NSYSQZS)<=NSYSCMP) return SYS_CMP;
    else if ((nsys-=NSYSCMP)<=NSYSIRN) return SYS_IRN;
    else if ((nsys-=NSYSIRN)<=NSYSLEO) return SYS_LEO;
    else                               return SYS_NONE;
}

extern int sys2num(int sys)
{
    switch (sys) {
        case SYS_GPS: return NSYSGPS;
        case SYS_GLO: return NSYSGPS+NSYSGLO;
        case SYS_GAL: return NSYSGPS+NSYSGLO+NSYSGAL;
        case SYS_QZS: return NSYSGPS+NSYSGLO+NSYSGAL+NSYSQZS;
        case SYS_CMP: return NSYSGPS+NSYSGLO+NSYSGAL+NSYSQZS+NSYSCMP;
        case SYS_IRN: return NSYSGPS+NSYSGLO+NSYSGAL+NSYSQZS+NSYSCMP+NSYSIRN;
        case SYS_LEO: return NSYSGPS+NSYSGLO+NSYSGAL+NSYSQZS+NSYSCMP+NSYSIRN+NSYSLEO;
        default: return 0;
    }
}
/* satellite id to satellite number --------------------------------------------
* convert satellite id to satellite number
* args   : char   *id       I   satellite id (nn,Gnn,Rnn,Enn,Jnn,Cnn,Inn or Snn)
* return : satellite number (0: error)
* notes  : 120-142 and 193-199 are also recognized as sbas and qzss
*-----------------------------------------------------------------------------*/
extern int satid2no(const char *id)
{
    int sys,prn;
    char code;

    if (sscanf(id,"%d",&prn)==1) {
        if      (MINPRNGPS<=prn&&prn<=MAXPRNGPS) sys=SYS_GPS;
        else if (MINPRNQZS<=prn&&prn<=MAXPRNQZS) sys=SYS_QZS;
        else return 0;
        return satno(sys,prn);
    }
    if (sscanf(id,"%c%d",&code,&prn)<2) return 0;

    switch (code) {
        case 'G': sys=SYS_GPS; prn+=MINPRNGPS-1; break;
        case 'R': sys=SYS_GLO; prn+=MINPRNGLO-1; break;
        case 'E': sys=SYS_GAL; prn+=MINPRNGAL-1; break;
        case 'J': sys=SYS_QZS; prn+=MINPRNQZS-1; break;
        case 'C': sys=SYS_CMP; prn+=MINPRNCMP-1; break;
        case 'I': sys=SYS_IRN; prn+=MINPRNIRN-1; break;
        case 'L': sys=SYS_LEO; prn+=MINPRNLEO-1; break;
        case 'S': sys=SYS_SBS; prn+=100; break;
        default: return 0;
    }
    return satno(sys,prn);
}
/* satellite number to satellite id --------------------------------------------
* convert satellite number to satellite id
* args   : int    sat       I   satellite number
*          char   *id       O   satellite id (Gnn,Rnn,Enn,Jnn,Cnn,Inn or nnn)
* return : none
*-----------------------------------------------------------------------------*/
extern void satno2id(int sat, char *id)
{
    int prn;
    switch (satsys(sat,&prn)) {
        case SYS_GPS: sprintf(id,"G%02d",prn-MINPRNGPS+1); return;
        case SYS_GLO: sprintf(id,"R%02d",prn-MINPRNGLO+1); return;
        case SYS_GAL: sprintf(id,"E%02d",prn-MINPRNGAL+1); return;
        case SYS_QZS: sprintf(id,"J%02d",prn-MINPRNQZS+1); return;
        case SYS_CMP: sprintf(id,"C%02d",prn-MINPRNCMP+1); return;
        case SYS_IRN: sprintf(id,"I%02d",prn-MINPRNIRN+1); return;
        case SYS_LEO: sprintf(id,"L%02d",prn-MINPRNLEO+1); return;
        case SYS_SBS: sprintf(id,"%03d" ,prn); return;
    }
    strcpy(id,"");
}
/* test excluded satellite -----------------------------------------------------
* test excluded satellite
* args   : int    sat       I   satellite number
*          double var       I   variance of ephemeris (m^2)
*          int    svh       I   sv health flag
*          prcopt_t *opt    I   processing options (NULL: not used)
* return : status (1:excluded,0:not excluded)
*-----------------------------------------------------------------------------*/
extern int satexclude(int sat,double var,int svh,const prcopt_t *opt)
{
    int sys=satsys(sat,NULL);
    
    if (svh<0) return 1; /* ephemeris unavailable */
    
    if (opt) {
        if (opt->exsats[sat-1]==1) return 1; /* excluded satellite */
        if (opt->exsats[sat-1]==2) return 0; /* included satellite */
        if (!(sys&opt->navsys)) return 1; /* unselected sat sys */
    }
    if (sys==SYS_QZS) svh&=0xFE; /* mask QZSS LEX health */

	if (svh) return 1;

	if (var>MAX_VAR_EPH) return 1;

    return 0;
}
/* test SNR mask ---------------------------------------------------------------
* test SNR mask
* args   : int    base      I   rover or base-station (0:rover,1:base station)
*          int    freq      I   frequency (0:L1,1:L2,2:L3,...)
*          double el        I   elevation angle (rad)
*          double snr       I   C/N0 (dBHz)
*          snrmask_t *mask  I   SNR mask
* return : status (1:masked,0:unmasked)
*-----------------------------------------------------------------------------*/
extern int testsnr(int base, int freq, double el, double snr,
                   const snrmask_t *mask)
{
	double minsnr;
    int f=mask->ena[base];

	if (base==0) f=1;

    if (!f||freq<0||freq>=NFREQ) return 0;
    
	minsnr=20;
	return snr<minsnr;
}
/* obs type string to obs code -------------------------------------------------
* convert obs code type string to obs code
* args   : char   *str   I      obs code string ("1C","1P","1Y",...)
*          int    *freq  IO     frequency (1:L1,2:L2,3:L5,4:L6,5:L7,6:L8,0:err)
*                               (NULL: no output)
* return : obs code (CODE_???)
* notes  : obs codes are based on reference [6] and qzss extension
*-----------------------------------------------------------------------------*/
extern unsigned char obs2code(const char *obs, int *freq)
{
    int i;
    if (freq) *freq=0;
    for (i=1;*obscodes[i];i++) {
        if (strcmp(obscodes[i],obs)) continue;
        if (freq) *freq=obsfreqs[i];
        return (unsigned char)i;
    }
    return CODE_NONE;
}
/* obs code to obs code string -------------------------------------------------
* convert obs code to obs code string
* args   : unsigned char code I obs code (CODE_???)
*          int    *freq  IO     frequency (NULL: no output)
*                               (1:L1/E1, 2:L2/B1, 3:L5/E5a/L3, 4:L6/LEX/B3,
                                 5:E5b/B2, 6:E5(a+b), 7:S)
* return : obs code string ("1C","1P","1P",...)
* notes  : obs codes are based on reference [6] and qzss extension
*-----------------------------------------------------------------------------*/
extern const char *code2obs(unsigned char code, int *freq)
{
    if (freq) *freq=0;
    if (code<=CODE_NONE||MAXCODE<code) return "";
    if (freq) *freq=obsfreqs[code];
    return obscodes[code];
}
/* set code priority -----------------------------------------------------------
* set code priority for multiple codes in a frequency
* args   : int    sys     I     system (or of SYS_???)
*          int    freq    I     frequency (1:L1,2:L2,3:L5,4:L6,5:L7,6:L8,7:L9)
*          char   *pri    I     priority of codes (series of code characters)
*                               (higher priority precedes lower)
* return : none
*-----------------------------------------------------------------------------*/
extern void setcodepri(int sys, int freq, const char *pri)
{
    if (freq<=0||MAXFREQ<freq) return;
    if (sys&SYS_GPS) strcpy(codepris[0][freq-1],pri);
    if (sys&SYS_GLO) strcpy(codepris[1][freq-1],pri);
    if (sys&SYS_GAL) strcpy(codepris[2][freq-1],pri);
    if (sys&SYS_QZS) strcpy(codepris[3][freq-1],pri);
    if (sys&SYS_SBS) strcpy(codepris[4][freq-1],pri);
    if (sys&SYS_CMP) strcpy(codepris[5][freq-1],pri);
    if (sys&SYS_IRN) strcpy(codepris[6][freq-1],pri);
}
/* get code priority -----------------------------------------------------------
* get code priority for multiple codes in a frequency
* args   : int    sys     I     system (SYS_???)
*          unsigned char code I obs code (CODE_???)
*          char   *opt    I     code options (NULL:no option)
* return : priority (15:highest-1:lowest,0:error)
*-----------------------------------------------------------------------------*/
extern int getcodepri(int sys, unsigned char code, const char *opt)
{
    const char *p,*optstr;
    const char* obs;
    char str[8]="";
    int i,j;
    
    switch (sys) {
        case SYS_GPS: i=0; optstr="-GL%2s"; break;
        case SYS_GLO: i=1; optstr="-RL%2s"; break;
        case SYS_GAL: i=2; optstr="-EL%2s"; break;
        case SYS_QZS: i=3; optstr="-JL%2s"; break;
        case SYS_SBS: i=4; optstr="-SL%2s"; break;
        case SYS_CMP: i=5; optstr="-CL%2s"; break;
        case SYS_IRN: i=6; optstr="-IL%2s"; break;
        default: return 0;
    }
    obs=code2obs(code,&j);
    
    /* parse code options */
    for (p=opt;p&&(p=strchr(p,'-'));p++) {
        if (sscanf(p,optstr,str)<1||str[0]!=obs[0]) continue;
        return str[1]==obs[1]?15:0;
    }
    /* search code priority */
    return (p=strchr(codepris[i][j-1],obs[1]))?14-(int)(p-codepris[i][j-1]):0;
}

/* new matrix */
extern double *mat(int n, int m)
{
    double *p;
    
    if (n<=0||m<=0) return NULL;
    if (!(p=(double *)calloc(sizeof(double),n*m))) {
        fatalerr("mat matrix memory allocation error: n=%d,m=%d\n",n,m);
    }
    return p;
}
/* new integer matrix */
extern int *imat(int n, int m)
{
    int *p;
    
    if (n<=0||m<=0) return NULL;
    if (!(p=(int *)calloc(sizeof(int),n*m))) {
        fatalerr("imat integer matrix memory allocation error: n=%d,m=%d\n",n,m);
    }
    return p;
}
/* zero matrix -----------------------------------------------------------------
* generate new zero matrix
* args   : int    n,m       I   number of rows and columns of matrix
* return : matrix pointer (if n<=0 or m<=0, return NULL)
*-----------------------------------------------------------------------------*/
extern double *zeros(int n, int m)
{

    double* p;

#if NOCALLOC
    if ((p = mat(n, m))) for (n = n * m - 1; n >= 0; n--) p[n] = 0.0;
#else
    if (n <= 0 || m <= 0) return NULL;
    if (!(p = (double*)calloc(sizeof(double), n * m))) {
        fatalerr("zeros matrix memory allocation error: n=%d,m=%d\n", n, m);
    }
#endif
    return p;
}
/* identity matrix -------------------------------------------------------------
* generate new identity matrix
* args   : int    n         I   number of rows and columns of matrix
* return : matrix pointer (if n<=0, return NULL)
*-----------------------------------------------------------------------------*/
extern double *eye(int n)
{
    double *p;
    int i;
    
    if ((p=zeros(n,n))) for (i=0;i<n;i++) p[i+i*n]=1.0;
    return p;
}
/* inner product ---------------------------------------------------------------
* inner product of vectors
* args   : double *a,*b     I   vector a,b (n x 1)
*          int    n         I   size of vector a,b
* return : a'*b
*-----------------------------------------------------------------------------*/
extern double dot(const double *a, const double *b, int n)
{
    double c=0.0;
    
    while (--n>=0) c+=a[n]*b[n];
    return c;
}
/* euclid norm -----------------------------------------------------------------
* euclid norm of vector
* args   : double *a        I   vector a (n x 1)
*          int    n         I   size of vector a
* return : || a ||
*-----------------------------------------------------------------------------*/
extern double norm(const double *a, int n)
{
    return sqrt(dot(a,a,n));
}
/* outer product of 3d vectors -------------------------------------------------
* outer product of 3d vectors 
* args   : double *a,*b     I   vector a,b (3 x 1)
*          double *c        O   outer product (a x b) (3 x 1)
* return : none
*-----------------------------------------------------------------------------*/
extern void cross3(const double *a, const double *b, double *c)
{
    c[0]=a[1]*b[2]-a[2]*b[1];
    c[1]=a[2]*b[0]-a[0]*b[2];
    c[2]=a[0]*b[1]-a[1]*b[0];
}
/* normalize 3d vector ---------------------------------------------------------
* normalize 3d vector
* args   : double *a        I   vector a (3 x 1)
*          double *b        O   normlized vector (3 x 1) || b || = 1
* return : status (1:ok,0:error)
*-----------------------------------------------------------------------------*/
extern int normv3(const double *a, double *b)
{
    double r;
    if ((r=norm(a,3))<=0.0) return 0;
    b[0]=a[0]/r;
    b[1]=a[1]/r;
    b[2]=a[2]/r;
    return 1;
}
/* normalize 3d vector ---------------------------------------------------------
* normalize 3d vector
* args   : double *a        I   vector a (3 x 1)
*          double *b        O   normlized vector (3 x 1) || b || = 1
* return : status (1:ok,0:error)
*-----------------------------------------------------------------------------*/
extern int normv4(const double *a, double *b)
{
    double r;
    if ((r=norm(a,4))<=0.0) return 0;
    b[0]=a[0]/r;
    b[1]=a[1]/r;
    b[2]=a[2]/r;
    b[3]=a[3]/r;
    return 1;
}
/* copy matrix -----------------------------------------------------------------
* copy matrix
* args   : double *A        O   destination matrix A (n x m)
*          double *B        I   source matrix B (n x m)
*          int    n,m       I   number of rows and columns of matrix
* return : none
*-----------------------------------------------------------------------------*/
extern void matcpy(double *A, const double *B, int n, int m)
{
    memcpy(A,B,sizeof(double)*n*m);
}
/* matrix routines -----------------------------------------------------------*/

#ifdef LAPACK /* with LAPACK/BLAS or MKL */
/* multiply matrix (wrapper of blas dgemm) -------------------------------------
* multiply matrix by matrix (C=alpha*A*B+beta*C)
* args   : char   *tr       I  transpose flags ("N":normal,"T":transpose)
*          int    n,k,m     I  size of (transposed) matrix A,B
*          double alpha     I  alpha
*          double *A,*B     I  (transposed) matrix A (n x m), B (m x k)
*          double beta      I  beta
*          double *C        IO matrix C (n x k)
* return : none
*-----------------------------------------------------------------------------*/
extern void matmul(const char *tr,int n,int k,int m,double alpha,const double *A,const double *B,double beta,double *C)
{
    int lda=tr[0]=='T'?m:n,ldb=tr[1]=='T'?k:m;
    
    dgemm_((char *)tr,(char *)tr+1,&n,&k,&m,&alpha,(double *)A,&lda,(double *)B,&ldb,&beta,C,&n);
}
/* inverse of matrix -----------------------------------------------------------
* inverse of matrix (A=A^-1)
* args   : double *A        IO  matrix (n x n)
*          int    n         I   size of matrix A
* return : status (0:ok,0>:error)
*-----------------------------------------------------------------------------*/
extern int matinv(double *A,int n)
{
    double *work;
    int info,lwork=n*16,*ipiv=imat(n,1);
    
    work=mat(lwork,1);
    dgetrf_(&n,&n,A,&n,ipiv,&info);
    if (!info) dgetri_(&n,A,&n,ipiv,work,&lwork,&info);
    free(ipiv); free(work);
    return info;
}
/* solve linear equation -------------------------------------------------------
* solve linear equation (X=A\Y or X=A'\Y)
* args   : char   *tr       I   transpose flag ("N":normal,"T":transpose)
*          double *A        I   input matrix A (n x n)
*          double *Y        I   input matrix Y (n x m)
*          int    n,m       I   size of matrix A,Y
*          double *X        O   X=A\Y or X=A'\Y (n x m)
* return : status (0:ok,0>:error)
* notes  : matirix stored by column-major order (fortran convention)
*          X can be same as Y
*-----------------------------------------------------------------------------*/
extern int solve(const char *tr,const double *A,const double *Y,int n,int m,double *X)
{
    double *B=mat(n,n);
    int info,*ipiv=imat(n,1);
    
    matcpy(B,A,n,n);
    matcpy(X,Y,n,m);
    dgetrf_(&n,&n,B,&n,ipiv,&info);
    if (!info) dgetrs_((char *)tr,&n,&m,B,&n,ipiv,X,&n,&info);
    free(ipiv); free(B); 
    return info;
}

#else /* without LAPACK/BLAS or MKL */

/* multiply matrix -----------------------------------------------------------
 * multiply matrix: C=alpha*A*B+beta*C
 * args   : tr[2]            I   transpose (T) or not (N) for A ([0]) and B ([1])
 *          *A               I   matrix A (m x n)
 *          *B               I   matrix B (k x m)
 *          *C               I   matrix C (k x n)
 */
extern void matmul(const char *tr,int n,int k,int m,double alpha,const double *A,const double *B,double beta,double *C)
{
    double d;
    int i, j, x, f = tr[0] == 'N' ? (tr[1] == 'N' ? 1 : 2) : (tr[1] == 'N' ? 3 : 4);

    for (i = 0; i < n; i++) for (j = 0; j < k; j++) {
        d = 0.0;
        switch (f) {
        case 1: for (x = 0; x < m; x++) d += A[i + x * n] * B[x + j * m]; break; // "NN"
        case 2: for (x = 0; x < m; x++) d += A[i + x * n] * B[j + x * k]; break; // "NT"
        case 3: for (x = 0; x < m; x++) d += A[x + i * m] * B[x + j * m]; break; // "TN"
        case 4: for (x = 0; x < m; x++) d += A[x + i * m] * B[j + x * k]; break; // "TT"
        }
        if (beta == 0.0) C[i + j * n] = alpha * d; else C[i + j * n] = alpha * d + beta * C[i + j * n];
    }
}
/* LU decomposition */
static int ludcmp(double *A,int n,int *indx,double *d)
{
    double big,s,tmp,*vv=mat(n,1);
    int i,imax=0,j,k;
    
    *d=1.0;
    for (i=0;i<n;i++) {
        big=0.0; for (j=0;j<n;j++) if ((tmp=fabs(A[i+j*n]))>big) big=tmp;
        if (big>0.0) vv[i]=1.0/big; else {free(vv); return -1;}
    }
    for (j=0;j<n;j++) {
        for (i=0;i<j;i++) {
            s=A[i+j*n]; for (k=0;k<i;k++) s-=A[i+k*n]*A[k+j*n]; A[i+j*n]=s;
        }
        big=0.0;
        for (i=j;i<n;i++) {
            s=A[i+j*n]; for (k=0;k<j;k++) s-=A[i+k*n]*A[k+j*n]; A[i+j*n]=s;
            if ((tmp=vv[i]*fabs(s))>=big) {big=tmp; imax=i;}
        }
        if (j!=imax) {
            for (k=0;k<n;k++) {
                tmp=A[imax+k*n]; A[imax+k*n]=A[j+k*n]; A[j+k*n]=tmp;
            }
            *d=-(*d); vv[imax]=vv[j];
        }
        indx[j]=imax;
        if (A[j+j*n]==0.0) {free(vv); return -1;}
        if (j!=n-1) {
            tmp=1.0/A[j+j*n]; for (i=j+1;i<n;i++) A[i+j*n]*=tmp;
        }
    }
    free(vv);
    return 0;
}
/* LU back-substitution */
static void lubksb(const double *A,int n,const int *indx,double *b)
{
    double s;
    int i,ii=-1,ip,j;
    
    for (i=0;i<n;i++) {
        ip=indx[i]; s=b[ip]; b[ip]=b[i];
        if (ii>=0) for (j=ii;j<i;j++) s-=A[i+j*n]*b[j]; else if (s) ii=i;
        b[i]=s;
    }
    for (i=n-1;i>=0;i--) {
        s=b[i]; for (j=i+1;j<n;j++) s-=A[i+j*n]*b[j]; b[i]=s/A[i+i*n];
    }
}
/* inverse of matrix */
extern int matinv(double *A,int n)
{
    double d,*B;
    int i,j,*indx;
    
    indx=imat(n,1); B=mat(n,n); matcpy(B,A,n,n);
    if (ludcmp(B,n,indx,&d)) {free(indx); free(B); return -1;}
    for (j=0;j<n;j++) {
        for (i=0;i<n;i++) A[i+j*n]=0.0;
        A[j+j*n]=1.0;
        lubksb(B,n,indx,A+j*n);
    }
    free(indx); free(B);
    return 0;
}
/* solve linear equation */
extern int solve(const char *tr,const double *A,const double *Y,int n,int m,double *X)
{
    double *B=mat(n,n);
    int info;
    
    matcpy(B,A,n,n);
    if (!(info=matinv(B,n))) matmul(tr[0]=='N'?"NN":"TN",n,m,n,1.0,B,Y,0.0,X);
    free(B);
    return info;
}
#endif
/* end of matrix routines ----------------------------------------------------*/

/* least square estimation -----------------------------------------------------
* least square estimation by solving normal equation (x=(A*A')^-1*A*y)
* args   : double *A        I   transpose of (weighted) design matrix (n x m)
*          double *y        I   (weighted) measurements (m x 1)
*          int    n,m       I   number of parameters and measurements (n<=m)
*          double *x        O   estmated parameters (n x 1)
*          double *Q        O   esimated parameters covariance matrix (n x n)
* return : status (0:ok,0>:error)
* notes  : for weighted least square, replace A and y by A*w and w*y (w=W^(1/2))
*          matirix stored by column-major order (fortran convention)
*-----------------------------------------------------------------------------*/
extern int lsq(const double *A,const double *y,int n,int m,double *x,double *Q)
{
    double *Ay;
    int info;
    
    if (m<n) return -1;
    Ay=mat(n,1);
    matmul("NN",n,1,m,1.0,A,y,0.0,Ay); /* Ay=A*y */
    matmul("NT",n,n,m,1.0,A,A,0.0,Q);  /* Q=A*A' */
    if (!(info=matinv(Q,n))) matmul("NN",n,1,n,1.0,Q,Ay,0.0,x); /* x=Q^-1*Ay */
    free(Ay);
    return info;
}
/* least square estimation -----------------------------------------------------
 * least square estimation by solving normal equation (x=(A*A')^-1*A*y)
 * args   : double *A        I   design matrix (m x n)
 *          double *P        I   covariance matrix of measurement error (m x m)
 *          double *y        I   measurements (m x 1)
 *          int    n,m       I   number of parameters and measurements (n<=m)
 *          double *x        O   estmated parameters (n x 1)
 *          double *Q        O   esimated parameters covariance matrix (n x n)
 *          double *v        O   innovation (measurement - model) (m x 1) 
 * return : status (0:ok,0>:error)
 * notes  : for weighted least square, replace A and y by A*w and w*y (w=W^(1/2))
 *          matirix stored by column-major order (fortran convention)
 *-----------------------------------------------------------------------------*/
extern int lsq_(const double *A,const double *P,const double *y,int n,int m,double *x,double *Q,double *v)
{
    double *Ap,*Apy;
    int info;
    
    if (m<n) return -1;
    Ap=zeros(n,m); 
    matmul("NT",n,m,m,1.0,A,P,0.0,Ap); /* Ap = A'*P: (n x m) = (n x m)(m x m), matirix Ap stored by column-major order */
	Apy=zeros(n,1);
    matmul("NN",n,1,m,1.0,Ap,y,0.0,Apy); /* Apy = A'*P*y: (n x 1) = (n x m)(m x 1), matirix Apy stored by column-major order */
    matmul("NT",n,n,m,1.0,Ap,A,0.0,Q); /* Q=A'*P*A */
    if (!(info=matinv(Q,n))) matmul("NN",n,1,n,1.0,Q,Apy,0.0,x); /* x=Q^-1*Apy */
	matcpy(v,y,m,1);
	matmul("TN",m,1,n,-1.0,A,x,1.0,v); /* v=y-A*x */
	free(Ap); free(Apy);
    return info;
}

/* string to number ------------------------------------------------------------
* convert substring in string to number
* args   : char   *s        I   string ("... nnn.nnn ...")
*          int    i,n       I   substring position and width
* return : converted number (0.0:error)
*-----------------------------------------------------------------------------*/
extern double str2num(const char *s,int i,int n)
{
    double value;
    char str[256],*p=str;
    
    if (i<0||(int)strlen(s)<i||(int)sizeof(str)-1<n) return 0.0;
    for (s+=i;*s&&--n>=0;s++) *p++=*s=='d'||*s=='D'?'E':*s;
    *p='\0';
    return sscanf(str,"%lf",&value)==1?value:0.0;
}
/* string to time --------------------------------------------------------------
* convert substring in string to gtime_t struct
* args   : char   *s        I   string ("... yyyy mm dd hh mm ss ...")
*          int    i,n       I   substring position and width
*          gtime_t *t       O   gtime_t struct
* return : status (0:ok,0>:error)
*-----------------------------------------------------------------------------*/
extern int str2time(const char *s,int i,int n,gtime_t *t)
{
    double ep[6];
    char str[256],*p=str;
    
    if (i<0||(int)strlen(s)<i||(int)sizeof(str)-1<i) return -1;
    for (s+=i;*s&&--n>=0;) *p++=*s++;
    *p='\0';
    if (sscanf(str,"%lf %lf %lf %lf %lf %lf",ep,ep+1,ep+2,ep+3,ep+4,ep+5)<6)
        return -1;
    if (ep[0]<100.0) ep[0]+=ep[0]<80.0?2000.0:1900.0;
    *t=epoch2time(ep);
    return 0;
}
/* transpose matrix-----------------------------------------------------------
 * args   : double  *A[m*n]      I   matrix
 *          int      n           I   rows of transpose matrix
 *          int      m           I   cols of transpose matrix
 *          double  *At[n*m]     O   transpose of matrix
 * return : none
 * --------------------------------------------------------------------------*/
extern void matt(const double *A,int n,int m,double *At)
{
    int i,j;
    for (i=0;i<n;i++) {
        j=0;
        for (j=0;j<m;j++) {
            At[i+j*n]=A[j+i*m];
        }
    }
}
/* standard deviation of value series-----------------------------------------------
 * args    : double *val    I  value series
 *           int     n      I  number of value
 * return  : standard Deviation
 * ---------------------------------------------------------------------------*/
extern double stds(const double *val,int n)
{
    int i;
    double mv,std,*vv=mat(n,1);

    for (mv=0.0,i=0;i<n;i++) mv+=val[i]; mv/=n;
    for (i=0;i<n;i++) vv[i]=val[i]-mv;

    std=sqrt(dot(vv,vv,n)/n); free(vv); return std;
}
extern double re_norm(double p)
{
    if(p==0.5) return 0.0;
    if(p>0.9999997) return 5.0;
    if(p<0.0000003) return -5.0;
    if(p<0.5) return -re_norm(1.0-p);

    double y=-log(4.0*p*(1.0-p));
    y=y*(1.570796288+y*(0.3706987906e-1
     +y*(-0.8364353589e-3+y*(-0.2250947176e-3
     +y*(0.6841218299e-5+y*(0.5824238515e-5
     +y*(-0.1045274970e-5+y*(0.8360937017e-7
     +y*(-0.3231081277e-8+y*(0.3657763036e-10
     +y*0.6936233982e-12))))))))));
    return sqrt(y);
}
/* convert calendar day/time to time -------------------------------------------
* convert calendar day/time to gtime_t struct
* args   : double *ep       I   day/time {year,month,day,hour,min,sec}
* return : gtime_t struct
* notes  : proper in 1970-2037 or 1970-2099 (64bit time_t)
*-----------------------------------------------------------------------------*/
extern gtime_t epoch2time(const double *ep)
{
    const int doy[]={1,32,60,91,121,152,182,213,244,274,305,335};
    gtime_t time={0};
    int days,sec,year=(int)ep[0],mon=(int)ep[1],day=(int)ep[2];
    
    if (year<1970||2099<year||mon<1||12<mon) return time;
    
    /* leap year if year%4==0 in 1901-2099 */
    days=(year-1970)*365+(year-1969)/4+doy[mon-1]+day-2+(year%4==0&&mon>=3?1:0);
    sec=(int)floor(ep[5]);
    time.time=(time_t)days*86400+(int)ep[3]*3600+(int)ep[4]*60+sec;
    time.sec=ep[5]-sec;
    return time;
}
/* time to calendar day/time */
extern void time2epoch(gtime_t t,double *ep)
{
    const int mday[]={ /* # of days in a month */
        31,28,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31,
        31,29,31,30,31,30,31,31,30,31,30,31,31,28,31,30,31,30,31,31,30,31,30,31
    };
    int days,sec,mon,day;
    
    /* leap year if year%4==0 in 1901-2099 */
    days=(int)(t.time/86400);
    sec=(int)(t.time-(time_t)days*86400);
    for (day=days%1461,mon=0;mon<48;mon++) {
        if (day>=mday[mon]) day-=mday[mon]; else break;
    }
    ep[0]=1970+days/1461*4+mon/12; ep[1]=mon%12+1; ep[2]=day+1;
    ep[3]=sec/3600; ep[4]=sec%3600/60; ep[5]=sec%60+t.sec;
}
/* gps time to time */
extern gtime_t gpst2time(int week,double sec)
{
    gtime_t t=epoch2time(gpst0);
    
    if (sec<-1E9||1E9<sec) sec=0.0;
    t.time+=(time_t)86400*7*week+(int)sec;
    t.sec=sec-(int)sec;
    return t;
}
/* time to gps time */
extern double time2gpst(gtime_t t,int *week)
{
    gtime_t t0=epoch2time(gpst0);
    time_t sec=t.time-t0.time;
    int w=(int)(sec/(86400*7));
    
    if (week) *week=w;
    return (double)(sec-(double)w*86400*7)+t.sec;
}
/* galileo system time to time */
extern gtime_t gst2time(int week,double sec)
{
    gtime_t t=epoch2time(gst0);
    
    if (sec<-1E9||1E9<sec) sec=0.0;
    t.time+=(time_t)86400*7*week+(int)sec;
    t.sec=sec-(int)sec;
    return t;
}
/* time to galileo system time */
extern double time2gst(gtime_t t,int *week)
{
    gtime_t t0=epoch2time(gst0);
    time_t sec=t.time-t0.time;
    int w=(int)(sec/(86400*7));
    
    if (week) *week=w;
    return (double)(sec-(double)w*86400*7)+t.sec;
}
/* beidou time (bdt) to time */
extern gtime_t bdt2time(int week,double sec)
{
    gtime_t t=epoch2time(bdt0);
    
    if (sec<-1E9||1E9<sec) sec=0.0;
    t.time+=(time_t)86400*7*week+(int)sec;
    t.sec=sec-(int)sec;
    return t;
}
/* time to beidouo time (bdt) */
extern double time2bdt(gtime_t t,int *week)
{
    gtime_t t0=epoch2time(bdt0);
    time_t sec=t.time-t0.time;
    int w=(int)(sec/(86400*7));
    
    if (week) *week=w;
    return (double)(sec-(double)w*86400*7)+t.sec;
}
/* add time */
extern gtime_t timeadd(gtime_t t,double sec)
{
    double tt;
    
    t.sec+=sec; tt=floor(t.sec); t.time+=(int)tt; t.sec-=tt;
    return t;
}
/* time difference */
extern double timediff(gtime_t t1,gtime_t t2)
{
    return difftime(t1.time,t2.time)+t1.sec-t2.sec;
}
/* gpstime to utc */
extern gtime_t gpst2utc(gtime_t t)
{
    gtime_t tu;
    int i;
    
    for (i=0;leaps[i][0]>0;i++) {
        tu=timeadd(t,leaps[i][6]);
        if (timediff(tu,epoch2time(leaps[i]))>=0.0) return tu;
    }
    return t;
}
/* utc to gpstime */
extern gtime_t utc2gpst(gtime_t t)
{
    int i;
    
    for (i=0;leaps[i][0]>0;i++) {
        if (timediff(t,epoch2time(leaps[i]))>=0.0) return timeadd(t,-leaps[i][6]);
    }
    return t;
}


/* bdt to gpstime */
extern gtime_t bdt2gpst(gtime_t t)
{
    return timeadd(t,14.0);
}
/* time to day and sec */
static double time2sec(gtime_t time,gtime_t *day)
{
    double ep[6],sec;
    time2epoch(time,ep);
    sec=ep[3]*3600.0+ep[4]*60.0+ep[5];
    ep[3]=ep[4]=ep[5]=0.0;
    *day=epoch2time(ep);
    return sec;
}

/* time to string */
extern void time2str(gtime_t t,char *s,int n)
{
    double ep[6];
    
    if (n<0) n=0; else if (n>12) n=12;
    if (1.0-t.sec<0.5/pow(10.0,n)) {t.time++; t.sec=0.0;};
    time2epoch(t,ep);
    int y=(int) ep[0];
    sprintf(s,"%04d %02.0f %02.0f %02.0f %02.0f %0*.*f",y,ep[1],ep[2],
            ep[3],ep[4],n<=0?2:n+3,n<=0?0:n,ep[5]);
}
extern void time2str3(gtime_t t, char* s, int n)
{
    double ep[6];

    if (n<0) n=0; else if (n>12) n=12;
    if (1.0-t.sec<0.5/pow(10.0,n)) {t.time++; t.sec=0.0;};
    time2epoch(t,ep);
    sprintf(s,"%04.0f/%02.0f/%02.0f %02.0f:%02.0f:%0*.*f",ep[0],ep[1],ep[2],
            ep[3],ep[4],n<=0?2:n+3,n<=0?0:n,ep[5]);
}
/* get time string */
extern char *time_str(gtime_t t, int n)
{
    static char buff[64];
    time2str(t,buff,n);
    return buff;
}
/* time to day of year */
extern double time2doy(gtime_t t)
{
    double ep[6];
    
    time2epoch(t,ep);
    ep[1]=ep[2]=1.0; ep[3]=ep[4]=ep[5]=0.0;
    return timediff(t,epoch2time(ep))/86400.0+1.0;
}
extern double time_doy(gtime_t t,int *year)
{
    double ep[6];
    time2epoch(t,ep);
	*year=(int)ep[0];
    ep[1]=ep[2]=1.0; ep[3]=ep[4]=ep[5]=0.0;
    return timediff(t,epoch2time(ep))/86400.0+1.0;
}
extern gtime_t yrdoy2time(const int yyyy, const int doy)
{
    int days_in_month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    int mm,dd,id;
    double ep[6]={0.0};

    /* check if yyyy is leap year */
    if (yyyy%4==0&&(yyyy%100!=0||yyyy%400==0)) days_in_month[1]=29;

    id=doy;
    dd=0;
    for (mm=0;mm<12;mm++) {
        id-=days_in_month[mm];
        if (id>0) continue;
        dd=id+days_in_month[mm];
        break;
    }
    mm++;
    ep[0]=(int)(yyyy); ep[1]=(int)(mm); ep[2]=(int)(dd);

    return epoch2time(ep);
}
extern double time2sod(gtime_t t)
{
    double ep[6]; ep[0]=0;
    int doy; int y;
    gtime_t t0;
    ep[1]=ep[2]=1.0; ep[3]=ep[4]=ep[5]=0.0;
    doy=(int)time_doy(t,&y); ep[0] = y;
    t0=epoch2time(ep);

    return timediff(t,t0)-(doy-1)*86400;
}
/* get tick time ---------------------------------------------------------------
* get current tick in ms
* args   : none
* return : current tick in ms
*-----------------------------------------------------------------------------*/
extern unsigned int tickget(void)
{
    return 0;
}
/* sleep ms --------------------------------------------------------------------
* sleep ms
* args   : int   ms         I   miliseconds to sleep (<0:no sleep)
* return : none
*-----------------------------------------------------------------------------*/
extern void sleepms(int ms)
{
#ifdef WIN32
    if (ms<5) Sleep(1); else Sleep(ms);
#else
    struct timespec ts;
    if (ms<=0) return;
    ts.tv_sec=(time_t)(ms/1000);
    ts.tv_nsec=(long)(ms%1000*1000000);
    nanosleep(&ts,NULL);
#endif
}
/* convert degree to deg-min-sec -----------------------------------------------
* convert degree to degree-minute-second
* args   : double deg       I   degree
*          double *dms      O   degree-minute-second {deg,min,sec}
*          int    ndec      I   number of decimals of second
* return : none
*-----------------------------------------------------------------------------*/
extern void deg2dms(double deg,double *dms,int ndec)
{
    double sign=deg<0.0?-1.0:1.0,a=fabs(deg);
    double unit=pow(0.1,ndec);
    dms[0]=floor(a); a=(a-dms[0])*60.0;
    dms[1]=floor(a); a=(a-dms[1])*60.0;
    dms[2]=floor(a/unit+0.5)*unit;
    if (dms[2]>=60.0) {
        dms[2]=0.0;
        dms[1]+=1.0;
        if (dms[1]>=60.0) {
            dms[1]=0.0;
            dms[0]+=1.0;
        }
    }
    dms[0]*=sign;
}
/* convert deg-min-sec to degree -----------------------------------------------
* convert degree-minute-second to degree
* args   : double *dms      I   degree-minute-second {deg,min,sec}
* return : degree
*-----------------------------------------------------------------------------*/
extern double dms2deg(const double *dms)
{
    double sign=dms[0]<0.0?-1.0:1.0;
    return sign*(fabs(dms[0])+dms[1]/60.0+dms[2]/3600.0);
}
/* transform ecef to geodetic postion ------------------------------------------
* transform ecef position to geodetic position
* args   : double *r        I   ecef position {x,y,z} (m)
*          double *pos      O   geodetic position {lat,lon,h} (rad,m)
* return : none
* notes  : WGS84, ellipsoidal height
*-----------------------------------------------------------------------------*/
extern void ecef2pos(const double *r,double *pos)
{
    double e2=FE_WGS84*(2.0-FE_WGS84),r2=dot(r,r,2),z,zk,v=RE_WGS84,sinp;
    
    for (z=r[2],zk=0.0;fabs(z-zk)>=1E-4;) {
        zk=z;
        sinp=z/sqrt(r2+z*z);
        v=RE_WGS84/sqrt(1.0-e2*sinp*sinp);
        z=r[2]+v*e2*sinp;
    }
    pos[0]=r2>1E-12?atan(z/sqrt(r2)):(r[2]>0.0?PI/2.0:-PI/2.0);
    pos[1]=r2>1E-12?atan2(r[1],r[0]):0.0;
    pos[2]=sqrt(r2+z*z)-v;
}
/* transform geodetic to ecef position -----------------------------------------
* transform geodetic position to ecef position
* args   : double *pos      I   geodetic position {lat,lon,h} (rad,m)
*          double *r        O   ecef position {x,y,z} (m)
* return : none
* notes  : WGS84, ellipsoidal height
*-----------------------------------------------------------------------------*/
extern void pos2ecef(const double *pos,double *r)
{
    double sinp=sin(pos[0]),cosp=cos(pos[0]),sinl=sin(pos[1]),cosl=cos(pos[1]);
    double e2=FE_WGS84*(2.0-FE_WGS84),v=RE_WGS84/sqrt(1.0-e2*sinp*sinp);
    
    r[0]=(v+pos[2])*cosp*cosl;
    r[1]=(v+pos[2])*cosp*sinl;
    r[2]=(v*(1.0-e2)+pos[2])*sinp;
}
/* ecef to local coordinate transfromation matrix ------------------------------
* compute ecef to local coordinate transfromation matrix
* args   : double *pos      I   geodetic position {lat,lon} (rad)
*          double *E        O   ecef to local coord transformation matrix (3x3)
* return : none
* notes  : matirix stored by column-major order (fortran convention)
*-----------------------------------------------------------------------------*/
extern void xyz2enu(const double *pos,double *E)
{
    double sinp=sin(pos[0]),cosp=cos(pos[0]),sinl=sin(pos[1]),cosl=cos(pos[1]);
    
    E[0]=-sinl;      E[3]=cosl;       E[6]=0.0;
    E[1]=-sinp*cosl; E[4]=-sinp*sinl; E[7]=cosp;
    E[2]=cosp*cosl;  E[5]=cosp*sinl;  E[8]=sinp;
}
/* transform ecef vector to local tangental coordinate -------------------------
* transform ecef vector to local tangental coordinate
* args   : double *pos      I   geodetic position {lat,lon} (rad)
*          double *r        I   vector in ecef coordinate {x,y,z}
*          double *e        O   vector in local tangental coordinate {e,n,u}
* return : none
*-----------------------------------------------------------------------------*/
extern void ecef2enu(const double *pos,const double *r,double *e)
{
    double E[9];
    
    xyz2enu(pos,E);
    matmul("NN",3,1,3,1.0,E,r,0.0,e);
}
/* transform local vector to ecef coordinate -----------------------------------
* transform local tangental coordinate vector to ecef
* args   : double *pos      I   geodetic position {lat,lon} (rad)
*          double *e        I   vector in local tangental coordinate {e,n,u}
*          double *r        O   vector in ecef coordinate {x,y,z}
* return : none
*-----------------------------------------------------------------------------*/
extern void enu2ecef(const double *pos,const double *e,double *r)
{
    double E[9];
    
    xyz2enu(pos,E);
    matmul("TN",3,1,3,1.0,E,e,0.0,r);
}
/* transform covariance to local tangental coordinate --------------------------
* transform ecef covariance to local tangental coordinate
* args   : double *pos      I   geodetic position {lat,lon} (rad)
*          double *P        I   covariance in ecef coordinate
*          double *Q        O   covariance in local tangental coordinate
* return : none
*-----------------------------------------------------------------------------*/
extern void covenu(const double *pos,const double *P,double *Q)
{
    double E[9],EP[9];
    
    xyz2enu(pos,E);
    matmul("NN",3,3,3,1.0,E,P,0.0,EP);
    matmul("NT",3,3,3,1.0,EP,E,0.0,Q);
}
/* transform local enu coordinate covariance to xyz-ecef -----------------------
* transform local enu covariance to xyz-ecef coordinate
* args   : double *pos      I   geodetic position {lat,lon} (rad)
*          double *Q        I   covariance in local enu coordinate
*          double *P        O   covariance in xyz-ecef coordinate
* return : none
*-----------------------------------------------------------------------------*/
extern void covecef(const double *pos,const double *Q,double *P)
{
    double E[9],EQ[9];
    
    xyz2enu(pos,E);
    matmul("TN",3,3,3,1.0,E,Q,0.0,EQ);
    matmul("NN",3,3,3,1.0,EQ,E,0.0,P);
}
/* coordinate rotation matrix ------------------------------------------------*/
#define Rx(t,X) do { \
    (X)[0]=1.0; (X)[1]=(X)[2]=(X)[3]=(X)[6]=0.0; \
    (X)[4]=(X)[8]=cos(t); (X)[7]=sin(t); (X)[5]=-(X)[7]; \
} while (0)

#define Ry(t,X) do { \
    (X)[4]=1.0; (X)[1]=(X)[3]=(X)[5]=(X)[7]=0.0; \
    (X)[0]=(X)[8]=cos(t); (X)[2]=sin(t); (X)[6]=-(X)[2]; \
} while (0)

#define Rz(t,X) do { \
    (X)[8]=1.0; (X)[2]=(X)[5]=(X)[6]=(X)[7]=0.0; \
    (X)[0]=(X)[4]=cos(t); (X)[3]=sin(t); (X)[1]=-(X)[3]; \
} while (0)

/* astronomical arguments: f={l,l',F,D,OMG} (rad) ----------------------------*/
static void ast_args(double t,double *f)
{
    static const double fc[][5]={ /* coefficients for iau 1980 nutation */
        { 134.96340251, 1717915923.2178,  31.8792,  0.051635, -0.00024470},
        { 357.52910918,  129596581.0481,  -0.5532,  0.000136, -0.00001149},
        {  93.27209062, 1739527262.8478, -12.7512, -0.001037,  0.00000417},
        { 297.85019547, 1602961601.2090,  -6.3706,  0.006593, -0.00003169},
        { 125.04455501,   -6962890.2665,   7.4722,  0.007702, -0.00005939}
    };
    double tt[4];
    int i,j;
    
    for (tt[0]=t,i=1;i<4;i++) tt[i]=tt[i-1]*t;
    for (i=0;i<5;i++) {
        f[i]=fc[i][0]*3600.0;
        for (j=0;j<4;j++) f[i]+=fc[i][j+1]*tt[j];
        f[i]=fmod(f[i]*AS2R,2.0*PI);
    }
}
/* iau 1980 nutation ---------------------------------------------------------*/
static void nut_iau1980(double t,const double *f,double *dpsi,double *deps)
{
    static const double nut[106][10]={
        {   0,   0,   0,   0,   1, -6798.4, -171996, -174.2, 92025,   8.9},
        {   0,   0,   2,  -2,   2,   182.6,  -13187,   -1.6,  5736,  -3.1},
        {   0,   0,   2,   0,   2,    13.7,   -2274,   -0.2,   977,  -0.5},
        {   0,   0,   0,   0,   2, -3399.2,    2062,    0.2,  -895,   0.5},
        {   0,  -1,   0,   0,   0,  -365.3,   -1426,    3.4,    54,  -0.1},
        {   1,   0,   0,   0,   0,    27.6,     712,    0.1,    -7,   0.0},
        {   0,   1,   2,  -2,   2,   121.7,    -517,    1.2,   224,  -0.6},
        {   0,   0,   2,   0,   1,    13.6,    -386,   -0.4,   200,   0.0},
        {   1,   0,   2,   0,   2,     9.1,    -301,    0.0,   129,  -0.1},
        {   0,  -1,   2,  -2,   2,   365.2,     217,   -0.5,   -95,   0.3},
        {  -1,   0,   0,   2,   0,    31.8,     158,    0.0,    -1,   0.0},
        {   0,   0,   2,  -2,   1,   177.8,     129,    0.1,   -70,   0.0},
        {  -1,   0,   2,   0,   2,    27.1,     123,    0.0,   -53,   0.0},
        {   1,   0,   0,   0,   1,    27.7,      63,    0.1,   -33,   0.0},
        {   0,   0,   0,   2,   0,    14.8,      63,    0.0,    -2,   0.0},
        {  -1,   0,   2,   2,   2,     9.6,     -59,    0.0,    26,   0.0},
        {  -1,   0,   0,   0,   1,   -27.4,     -58,   -0.1,    32,   0.0},
        {   1,   0,   2,   0,   1,     9.1,     -51,    0.0,    27,   0.0},
        {  -2,   0,   0,   2,   0,  -205.9,     -48,    0.0,     1,   0.0},
        {  -2,   0,   2,   0,   1,  1305.5,      46,    0.0,   -24,   0.0},
        {   0,   0,   2,   2,   2,     7.1,     -38,    0.0,    16,   0.0},
        {   2,   0,   2,   0,   2,     6.9,     -31,    0.0,    13,   0.0},
        {   2,   0,   0,   0,   0,    13.8,      29,    0.0,    -1,   0.0},
        {   1,   0,   2,  -2,   2,    23.9,      29,    0.0,   -12,   0.0},
        {   0,   0,   2,   0,   0,    13.6,      26,    0.0,    -1,   0.0},
        {   0,   0,   2,  -2,   0,   173.3,     -22,    0.0,     0,   0.0},
        {  -1,   0,   2,   0,   1,    27.0,      21,    0.0,   -10,   0.0},
        {   0,   2,   0,   0,   0,   182.6,      17,   -0.1,     0,   0.0},
        {   0,   2,   2,  -2,   2,    91.3,     -16,    0.1,     7,   0.0},
        {  -1,   0,   0,   2,   1,    32.0,      16,    0.0,    -8,   0.0},
        {   0,   1,   0,   0,   1,   386.0,     -15,    0.0,     9,   0.0},
        {   1,   0,   0,  -2,   1,   -31.7,     -13,    0.0,     7,   0.0},
        {   0,  -1,   0,   0,   1,  -346.6,     -12,    0.0,     6,   0.0},
        {   2,   0,  -2,   0,   0, -1095.2,      11,    0.0,     0,   0.0},
        {  -1,   0,   2,   2,   1,     9.5,     -10,    0.0,     5,   0.0},
        {   1,   0,   2,   2,   2,     5.6,      -8,    0.0,     3,   0.0},
        {   0,  -1,   2,   0,   2,    14.2,      -7,    0.0,     3,   0.0},
        {   0,   0,   2,   2,   1,     7.1,      -7,    0.0,     3,   0.0},
        {   1,   1,   0,  -2,   0,   -34.8,      -7,    0.0,     0,   0.0},
        {   0,   1,   2,   0,   2,    13.2,       7,    0.0,    -3,   0.0},
        {  -2,   0,   0,   2,   1,  -199.8,      -6,    0.0,     3,   0.0},
        {   0,   0,   0,   2,   1,    14.8,      -6,    0.0,     3,   0.0},
        {   2,   0,   2,  -2,   2,    12.8,       6,    0.0,    -3,   0.0},
        {   1,   0,   0,   2,   0,     9.6,       6,    0.0,     0,   0.0},
        {   1,   0,   2,  -2,   1,    23.9,       6,    0.0,    -3,   0.0},
        {   0,   0,   0,  -2,   1,   -14.7,      -5,    0.0,     3,   0.0},
        {   0,  -1,   2,  -2,   1,   346.6,      -5,    0.0,     3,   0.0},
        {   2,   0,   2,   0,   1,     6.9,      -5,    0.0,     3,   0.0},
        {   1,  -1,   0,   0,   0,    29.8,       5,    0.0,     0,   0.0},
        {   1,   0,   0,  -1,   0,   411.8,      -4,    0.0,     0,   0.0},
        {   0,   0,   0,   1,   0,    29.5,      -4,    0.0,     0,   0.0},
        {   0,   1,   0,  -2,   0,   -15.4,      -4,    0.0,     0,   0.0},
        {   1,   0,  -2,   0,   0,   -26.9,       4,    0.0,     0,   0.0},
        {   2,   0,   0,  -2,   1,   212.3,       4,    0.0,    -2,   0.0},
        {   0,   1,   2,  -2,   1,   119.6,       4,    0.0,    -2,   0.0},
        {   1,   1,   0,   0,   0,    25.6,      -3,    0.0,     0,   0.0},
        {   1,  -1,   0,  -1,   0, -3232.9,      -3,    0.0,     0,   0.0},
        {  -1,  -1,   2,   2,   2,     9.8,      -3,    0.0,     1,   0.0},
        {   0,  -1,   2,   2,   2,     7.2,      -3,    0.0,     1,   0.0},
        {   1,  -1,   2,   0,   2,     9.4,      -3,    0.0,     1,   0.0},
        {   3,   0,   2,   0,   2,     5.5,      -3,    0.0,     1,   0.0},
        {  -2,   0,   2,   0,   2,  1615.7,      -3,    0.0,     1,   0.0},
        {   1,   0,   2,   0,   0,     9.1,       3,    0.0,     0,   0.0},
        {  -1,   0,   2,   4,   2,     5.8,      -2,    0.0,     1,   0.0},
        {   1,   0,   0,   0,   2,    27.8,      -2,    0.0,     1,   0.0},
        {  -1,   0,   2,  -2,   1,   -32.6,      -2,    0.0,     1,   0.0},
        {   0,  -2,   2,  -2,   1,  6786.3,      -2,    0.0,     1,   0.0},
        {  -2,   0,   0,   0,   1,   -13.7,      -2,    0.0,     1,   0.0},
        {   2,   0,   0,   0,   1,    13.8,       2,    0.0,    -1,   0.0},
        {   3,   0,   0,   0,   0,     9.2,       2,    0.0,     0,   0.0},
        {   1,   1,   2,   0,   2,     8.9,       2,    0.0,    -1,   0.0},
        {   0,   0,   2,   1,   2,     9.3,       2,    0.0,    -1,   0.0},
        {   1,   0,   0,   2,   1,     9.6,      -1,    0.0,     0,   0.0},
        {   1,   0,   2,   2,   1,     5.6,      -1,    0.0,     1,   0.0},
        {   1,   1,   0,  -2,   1,   -34.7,      -1,    0.0,     0,   0.0},
        {   0,   1,   0,   2,   0,    14.2,      -1,    0.0,     0,   0.0},
        {   0,   1,   2,  -2,   0,   117.5,      -1,    0.0,     0,   0.0},
        {   0,   1,  -2,   2,   0,  -329.8,      -1,    0.0,     0,   0.0},
        {   1,   0,  -2,   2,   0,    23.8,      -1,    0.0,     0,   0.0},
        {   1,   0,  -2,  -2,   0,    -9.5,      -1,    0.0,     0,   0.0},
        {   1,   0,   2,  -2,   0,    32.8,      -1,    0.0,     0,   0.0},
        {   1,   0,   0,  -4,   0,   -10.1,      -1,    0.0,     0,   0.0},
        {   2,   0,   0,  -4,   0,   -15.9,      -1,    0.0,     0,   0.0},
        {   0,   0,   2,   4,   2,     4.8,      -1,    0.0,     0,   0.0},
        {   0,   0,   2,  -1,   2,    25.4,      -1,    0.0,     0,   0.0},
        {  -2,   0,   2,   4,   2,     7.3,      -1,    0.0,     1,   0.0},
        {   2,   0,   2,   2,   2,     4.7,      -1,    0.0,     0,   0.0},
        {   0,  -1,   2,   0,   1,    14.2,      -1,    0.0,     0,   0.0},
        {   0,   0,  -2,   0,   1,   -13.6,      -1,    0.0,     0,   0.0},
        {   0,   0,   4,  -2,   2,    12.7,       1,    0.0,     0,   0.0},
        {   0,   1,   0,   0,   2,   409.2,       1,    0.0,     0,   0.0},
        {   1,   1,   2,  -2,   2,    22.5,       1,    0.0,    -1,   0.0},
        {   3,   0,   2,  -2,   2,     8.7,       1,    0.0,     0,   0.0},
        {  -2,   0,   2,   2,   2,    14.6,       1,    0.0,    -1,   0.0},
        {  -1,   0,   0,   0,   2,   -27.3,       1,    0.0,    -1,   0.0},
        {   0,   0,  -2,   2,   1,  -169.0,       1,    0.0,     0,   0.0},
        {   0,   1,   2,   0,   1,    13.1,       1,    0.0,     0,   0.0},
        {  -1,   0,   4,   0,   2,     9.1,       1,    0.0,     0,   0.0},
        {   2,   1,   0,  -2,   0,   131.7,       1,    0.0,     0,   0.0},
        {   2,   0,   0,   2,   0,     7.1,       1,    0.0,     0,   0.0},
        {   2,   0,   2,  -2,   1,    12.8,       1,    0.0,    -1,   0.0},
        {   2,   0,  -2,   0,   1,  -943.2,       1,    0.0,     0,   0.0},
        {   1,  -1,   0,  -2,   0,   -29.3,       1,    0.0,     0,   0.0},
        {  -1,   0,   0,   1,   1,  -388.3,       1,    0.0,     0,   0.0},
        {  -1,  -1,   0,   2,   1,    35.0,       1,    0.0,     0,   0.0},
        {   0,   1,   0,   1,   0,    27.3,       1,    0.0,     0,   0.0}
    };
    double ang;
    int i,j;
    
    *dpsi=*deps=0.0;
    
    for (i=0;i<106;i++) {
        ang=0.0;
        for (j=0;j<5;j++) ang+=nut[i][j]*f[j];
        *dpsi+=(nut[i][6]+nut[i][7]*t)*sin(ang);
        *deps+=(nut[i][8]+nut[i][9]*t)*cos(ang);
    }
    *dpsi*=1E-4*AS2R; /* 0.1 mas -> rad */
    *deps*=1E-4*AS2R;
}

/* decode antenna parameter field --------------------------------------------*/
static int decodef(char *p,int n,double *v)
{
    int i;
    
    for (i=0;i<n;i++) v[i]=0.0;
    for (i=0,p=strtok(p," ");p&&i<n;p=strtok(NULL," ")) {
        v[i++]=atof(p)*1E-3;
    }
    return i;
}
/* add antenna parameter -----------------------------------------------------*/
static void addpcv(const pcv_t *pcv,pcvs_t *pcvs)
{
    pcv_t *pcvs_pcv;
    
    if (pcvs->nmax<=pcvs->n) {
        pcvs->nmax+=256;
        if (!(pcvs_pcv=(pcv_t *)realloc(pcvs->pcv,sizeof(pcv_t)*pcvs->nmax))) {
            free(pcvs->pcv); pcvs->pcv=NULL; pcvs->n=pcvs->nmax=0;
            return;
        }
        pcvs->pcv=pcvs_pcv;
    }
    pcvs->pcv[pcvs->n++]=*pcv;
}
/* read antex file ----------------------------------------------------------*/
static int readantex(const char *file,pcvs_t *pcvs, prcopt_t* popt)
{
    FILE *fp;
    static const pcv_t pcv0={0};
    pcv_t pcv;
    double neu[3];
    int i,f,freq=0,state=0,freqs[]={1,2,5,6,7,8,0};
    char buff[256];
    int sys;
    
    if (!(fp=fopen(file,"r"))) {
        return 0;
    }
    while (fgets(buff,sizeof(buff),fp)) {
        
        if (strlen(buff)<60||strstr(buff+60,"COMMENT")) continue;
        
        if (strstr(buff+60,"START OF ANTENNA")) {
            pcv=pcv0;
            state=1;
        }
        if (strstr(buff+60,"END OF ANTENNA")) {
            addpcv(&pcv,pcvs);
            state=0;
        }
        if (!state) continue;
        
        if (strstr(buff+60,"TYPE / SERIAL NO")) {
            strncpy(pcv.type,buff   ,20); pcv.type[20]='\0';
            strncpy(pcv.code,buff+20,20); pcv.code[20]='\0';
            if (!strncmp(pcv.code+3,"        ",8)) {
                pcv.sat=satid2no(pcv.code);
            }
        }
        else if (strstr(buff+60,"VALID FROM")) {
            if (!str2time(buff,0,43,&pcv.ts)) continue;
        }
        else if (strstr(buff+60,"VALID UNTIL")) {
            if (!str2time(buff,0,43,&pcv.te)) continue;
        }
        else if (strstr(buff+60,"START OF FREQUENCY")) {
            if (sscanf(buff+4,"%d",&f)<1) continue;
            for (i=0;i<7;i++) if (freqs[i]==f) break;
            if (i<7) freq=i+1;
            sys=satsys(pcv.sat,NULL);
            if (popt->bds2 == 1) {
                if (sys == SYS_CMP) {
                    if (freq == 2) freq = 1; /* B1-2      */
                    else if (freq == 4) freq = 2; /* B3        */
                    else if (freq == 5) freq = 3; /* B2b(BDS-2)*/
                    else if (freq == 3) freq = 5; /* B2 (BDS-3)*/
                    else if (freq == 6) freq = 6; /* B2a(BDS-3)*/
                    else if (freq == 7) freq = 7; /* B2b(BDS-3)*/
                    else if (freq == 1) freq = 4; /* B1 (BDS-3)ver!=3.02*/
                    //else if (freq==1) freq=1; /* B1-2    ver==3.02*/
                }
            }
            else {
                if (sys == SYS_CMP) {
                    if (freq == 2) freq = 1; /* B1-2      */
                    else if (freq == 4) freq = 2; /* B3        */
                    else if (freq == 7) freq = 3; /* B2b(BDS-3)*/
                    else if (freq == 1) freq = 4; /* B1 (BDS-3)ver!=3.02*/
                    else if (freq == 3) freq = 5; /* B2 (BDS-3)*/
                    else if (freq == 6) freq = 7; /* B2a(BDS-3)*/
                    else if (freq == 5) freq = 6; /* B2b(BDS-2)*/
                    //else if (freq==1) freq=1; /* B1-2    ver==3.02*/
                }
            }
            if (sys==SYS_GAL){
                if      (freq==3) freq=2; /* E5a       */
                else if (freq==5) freq=3; /* E5b       */
                else if (freq==6) freq=5; /* E5        */
            }
        }
        else if (strstr(buff+60,"END OF FREQUENCY")) {
            freq=0;
        }
        else if (strstr(buff+60,"NORTH / EAST / UP")) {
            if (freq<1||NFREQ<freq) continue;
            if (decodef(buff,3,neu)<3) continue;
            pcv.off[freq-1][0]=neu[pcv.sat?0:1]; /* x or e */
            pcv.off[freq-1][1]=neu[pcv.sat?1:0]; /* y or n */
            pcv.off[freq-1][2]=neu[2];           /* z or u */
        }
        else if (strstr(buff,"NOAZI")) {
            if (freq<1||NFREQ<freq) continue;
            if ((i=decodef(buff+8,19,pcv.var[freq-1]))<=0) continue;
            for (;i<19;i++) pcv.var[freq-1][i]=pcv.var[freq-1][i-1];
        }
    }
    fclose(fp);
    
    return 1;
}

/* add receiver parameter----------------------------------------------------*/
static void _addpcv(const _pcv_t*pcv,pcvr_t*pcvr)
{
	_pcv_t *pcvr_pcv;

	if (pcvr->nmax<=pcvr->n) {
		pcvr->nmax+=256;
		if (!(pcvr_pcv=(_pcv_t *)realloc(pcvr->pcv,sizeof(_pcv_t)*pcvr->nmax))) {
			free(pcvr->pcv); pcvr->pcv=NULL; pcvr->n=pcvr->nmax = 0;
			return;
		}
		pcvr->pcv=pcvr_pcv;
	}
	pcvr->pcv[pcvr->n++]=*pcv;
}

static int readantexr(const char *file,const char *anttype,pcvr_t *pcvr)
{
    FILE *fp;
    static const _pcv_t pcv0={0};
    _pcv_t pcv;
    double neu[3],dazi;
    int i,k,n=0,f,freq=0,state=0,freqs[]={1,2,5,6,7,8,0},sum=0;
    char buff[256],buffe[64]={0},*types[MAXRCV],*p,temp[256]={0};
	

	strcpy(buffe,anttype);
	for (p=strtok(buffe,",");p&&n<MAXRCV;p=strtok(NULL,",")) types[n++]=p;
	if (n<=0) return 0;
    
    if (!(fp=fopen(file,"r"))) return 0;

    while (fgets(buff,sizeof(buff),fp)) {
        
        if (strlen(buff)<60||strstr(buff+60,"COMMENT")) continue;
        
        if (strstr(buff+60,"START OF ANTENNA")) {
            pcv=pcv0;
            state=1;
			dazi =0;
        }
        if (strstr(buff+60,"END OF ANTENNA")) {
			state=0;
			/* search receiver antenna with radome at first */
			for (i=0;i<n;++i) {
                if (strstr(pcv.type,types[i])!=NULL) 
					break;
			}
			if (i<n) {
				_addpcv(&pcv,pcvr);
				sum++;
			}
			if (sum==n) break;
        }
        if (!state) continue;
        
        if (strstr(buff+60,"TYPE / SERIAL NO")) {
            strncpy(pcv.type,buff   ,20); pcv.type[20]='\0';
            strncpy(pcv.code,buff+20,20); pcv.code[20]='\0';
        }
		if (strstr(buff+60,"DAZI")) {
			memset(temp,0,sizeof(temp));
			memcpy(temp,buff,10);
			dazi=atof(temp);
        }
        else if (strstr(buff+60,"VALID FROM")) {
            if (!str2time(buff,0,43,&pcv.ts)) continue;
        }
        else if (strstr(buff+60,"VALID UNTIL")) {
            if (!str2time(buff,0,43,&pcv.te)) continue;
        }
        else if (strstr(buff+60,"START OF FREQUENCY")) {
            if (buff[3]!='G') continue;
            if (sscanf(buff+4,"%d",&f)<1) continue;
            for (i=0;i<NFREQ;i++) if (freqs[i]==f) break;
            if (i<NFREQ) freq=i+1;
        }
        else if (strstr(buff+60,"END OF FREQUENCY")) {
            freq=0;
        }
        else if (strstr(buff+60,"NORTH / EAST / UP")) {
            if (freq<1||NFREQ<freq) continue;
            if (decodef(buff,3,neu)<3) continue;
            pcv.off[freq-1][0]=neu[1]; /* e */
            pcv.off[freq-1][1]=neu[0]; /* n */
            pcv.off[freq-1][2]=neu[2]; /* u */
        }
        else if (strstr(buff,"NOAZI")) {
            if (freq<1||NFREQ<freq) continue;

			if (dazi!=5.0) {
				if ((i=decodef(buff+8,19,pcv.var[freq-1][0]))<=0) continue;
				for (;i<19;++i) pcv.var[freq-1][0][i]=pcv.var[freq-1][0][i-1];
				pcv.num[freq-1]=1;
			}
			else {
				for (i=0;i<19;++i) pcv.var[freq-1][0][i]=0;
				pcv.num[freq-1]=0;
				while (fgets(buff,sizeof(buff),fp)) {
					if (strlen(buff)<60||strstr(buff+60,"COMMENT")) continue;

					if (strstr(buff+60,"END OF FREQUENCY")) {
						freq=0;
						break;
					}
					memset(temp,0,sizeof(temp));
					memcpy(temp,buff,10);
					k=(int)floor(atof(temp)/5.0);
					if (k>=73) continue;
					if ((i=decodef(buff+8,19,pcv.var[freq-1][k]))<=0) continue;
					for (;i<19;++i) pcv.var[freq-1][k][i]=pcv.var[freq-1][k][i-1];
					pcv.num[freq-1]+=1;
				}
			}
        }
    }
    fclose(fp);
    
    return 1;
}

/* read antenna parameters ------------------------------------------------------
* read antenna parameters
* args   : char   *file       I   antenna parameter file (antex)
*          pcvs_t *pcvs       IO  antenna parameters
* return : status (1:ok,0:file open error)
* notes  : file with the externsion .atx or .ATX is recognized as antex
*          file except for antex is recognized ngs antenna parameters
*          see reference [3]
*          only support non-azimuth-depedent parameters
*-----------------------------------------------------------------------------*/
extern int readpcv(const char *file,pcvs_t *pcvs, prcopt_t* popt)
{
    const char *ext;
    int stat;
    
    if (!(ext=strrchr(file,'.'))) ext="";
    
    if (!strcmp(ext,".atx")||!strcmp(ext,".ATX")) {
        stat=readantex(file,pcvs,popt);
    }
    return stat;
}
extern int readpcvr(const char *file,const char *anttype,pcvr_t *pcvr)
{
    const char *ext;
    int stat;
    
    if (!(ext=strrchr(file,'.'))) ext="";
    
    if (!strcmp(ext,".atx")||!strcmp(ext,".ATX")) {
        stat=readantexr(file,anttype,pcvr);
    }
    return stat;
}
/* search antenna parameter ----------------------------------------------------
* read satellite antenna phase center position
* args   : int    sat         I   satellite number (0: receiver antenna)
*          char   *type       I   antenna type for receiver antenna
*          gtime_t time       I   time to search parameters
*          pcvs_t *pcvs       IO  antenna parameters
* return : antenna parameter (NULL: no antenna)
*-----------------------------------------------------------------------------*/
extern pcv_t *searchpcv(int sat,gtime_t time,const pcvs_t *pcvs)
{
    pcv_t *pcv;
    int i,n=0;
    
    if (sat) { /* search satellite antenna */
        for (i=0;i<pcvs->n;i++) {
            pcv=pcvs->pcv+i;
            if (pcv->sat!=sat) continue;
            if (pcv->ts.time!=0&&timediff(pcv->ts,time)>0.0) continue;
            if (pcv->te.time!=0&&timediff(pcv->te,time)<0.0) continue;
            return pcv;
        }
    }
    return NULL;
}
/* compare ephemeris ---------------------------------------------------------*/
static int cmpeph(const void *p1,const void *p2)
{
    eph_t *q1=(eph_t *)p1,*q2=(eph_t *)p2;
    return q1->ttr.time!=q2->ttr.time?(int)(q1->ttr.time-q2->ttr.time):
           (q1->toe.time!=q2->toe.time?(int)(q1->toe.time-q2->toe.time):
            q1->sat-q2->sat);
}
/* sort and unique ephemeris -------------------------------------------------*/
static void uniqeph(nav_t *nav)
{
    eph_t *nav_eph;
    int i,j;
    
    if (nav->n<=0) return;
    
    qsort(nav->eph,nav->n,sizeof(eph_t),cmpeph);
    
    for (i=1,j=0;i<nav->n;i++) {
        if (nav->eph[i].sat!=nav->eph[j].sat||
            nav->eph[i].iode!=nav->eph[j].iode) {
            nav->eph[++j]=nav->eph[i];
        }
    }
    nav->n=j+1;
    
    if (!(nav_eph=(eph_t *)realloc(nav->eph,sizeof(eph_t)*nav->n))) {
        free(nav->eph); nav->eph=NULL; nav->n=nav->nmax=0;
        return;
    }
    nav->eph=nav_eph;
    nav->nmax=nav->n;
}
/* compare glonass ephemeris -------------------------------------------------*/
static int cmpgeph(const void *p1,const void *p2)
{
    geph_t *q1=(geph_t *)p1,*q2=(geph_t *)p2;
    return q1->tof.time!=q2->tof.time?(int)(q1->tof.time-q2->tof.time):
           (q1->toe.time!=q2->toe.time?(int)(q1->toe.time-q2->toe.time):
            q1->sat-q2->sat);
}
/* sort and unique glonass ephemeris -----------------------------------------*/
static void uniqgeph(nav_t *nav)
{
    geph_t *nav_geph;
    int i,j;
    
    if (nav->ng<=0) return;
    
    qsort(nav->geph,nav->ng,sizeof(geph_t),cmpgeph);
    
    for (i=j=0;i<nav->ng;i++) {
        if (nav->geph[i].sat!=nav->geph[j].sat||
            nav->geph[i].toe.time!=nav->geph[j].toe.time||
            nav->geph[i].svh!=nav->geph[j].svh) {
            nav->geph[++j]=nav->geph[i];
        }
    }
    nav->ng=j+1;
    
    if (!(nav_geph=(geph_t *)realloc(nav->geph,sizeof(geph_t)*nav->ng))) {
        free(nav->geph); nav->geph=NULL; nav->ng=nav->ngmax=0;
        return;
    }
    nav->geph=nav_geph;
    nav->ngmax=nav->ng;
}
/* unique ephemerides ----------------------------------------------------------
* unique ephemerides in navigation data and update carrier wave length
* args   : nav_t *nav    IO     navigation data
* return : number of epochs
*-----------------------------------------------------------------------------*/
extern void uniqnav(nav_t *nav, const prcopt_t* popt)
{
    int i,j;
    
    /* unique ephemeris */
    uniqeph (nav);
    uniqgeph(nav);
    
    /* update carrier wave length */
    for (i=0;i<MAXSAT;i++) for (j=0;j<NFREQ;j++) {
        nav->lam[i][j]=satwavelen(i+1,j,nav,popt);
    }
}
/* compare observation data -------------------------------------------------*/
static int cmpobs(const void *p1,const void *p2)
{
    obsd_t *q1=(obsd_t *)p1,*q2=(obsd_t *)p2;
    double tt=timediff(q1->time,q2->time);
    if (fabs(tt)>DTTOL) return tt<0?-1:1;
    if (q1->rcv!=q2->rcv) return (int)q1->rcv-(int)q2->rcv;
    return (int)q1->sat-(int)q2->sat;
}
/* sort and unique observation data --------------------------------------------
* sort and unique observation data by time, rcv, sat
* args   : obs_t *obs    IO     observation data
* return : number of epochs
*-----------------------------------------------------------------------------*/
extern int sortobs(obs_t *obs)
{
    int i,j;
    if (obs->n<=0) return 0;
    qsort(obs->data,obs->n,sizeof(obsd_t),cmpobs);
    /* delete duplicated data */
    for (i=j=0;i<obs->n;i++) {
        if (obs->data[i].sat!=obs->data[j].sat||
            obs->data[i].rcv!=obs->data[j].rcv||
            timediff(obs->data[i].time,obs->data[j].time)!=0.0) {
            obs->data[++j]=obs->data[i];
        }
    }
    obs->n=j+1;
    return obs->n;
}
/* screen by time --------------------------------------------------------------
* screening by time start, time end, and time interval
* args   : gtime_t time  I      time
*          gtime_t ts    I      time start (ts.time==0:no screening by ts)
*          gtime_t te    I      time end   (te.time==0:no screening by te)
*          double  tint  I      time interval (s) (0.0:no screen by tint)
* return : 1:on condition, 0:not on condition
*-----------------------------------------------------------------------------*/
extern int screent(gtime_t time,gtime_t ts,gtime_t te,double tint)
{
    return (tint<=0.0||fmod(time2gpst(time,NULL)+DTTOL,tint)<=DTTOL*2.0)&&
           (ts.time==0||timediff(time,ts)>=-DTTOL)&&
           (te.time==0||timediff(time,te)<  DTTOL);
}
/* free observation data -------------------------------------------------------
* free memory for observation data
* args   : obs_t *obs    IO     observation data
* return : none
*-----------------------------------------------------------------------------*/
extern void freeobs(obs_t *obs)
{
    free(obs->data); obs->data=NULL; obs->n=obs->nmax=0;
}
/* free navigation data ---------------------------------------------------------
* free memory for navigation data
* args   : nav_t *nav    IO     navigation data
*          int   opt     I      option (or of followings)
*                               (0x01: gps/qzs ephmeris, 0x02: glonass ephemeris,
*                                0x04: sbas ephemeris,   0x08: precise ephemeris,
*                                0x10: precise clock     0x20: almanac,
*                                0x40: tec data)
* return : none
*-----------------------------------------------------------------------------*/
extern void freenav(nav_t *nav,int opt)
{
    if (opt&0x01) {free(nav->eph ); nav->eph =NULL; nav->n =nav->nmax =0;}
    if (opt&0x02) {free(nav->geph); nav->geph=NULL; nav->ng=nav->ngmax=0;}
}


/* execute command -------------------------------------------------------------
* execute command line by operating system shell
* args   : char   *cmd      I   command line
* return : execution status (0:ok,0>:error)
*-----------------------------------------------------------------------------*/
extern int execcmd(const char *cmd)
{
#ifdef WIN32
    PROCESS_INFORMATION info;
    STARTUPINFO si={0};
    DWORD stat;
    char cmds[1024];
    
    si.cb=sizeof(si);
    sprintf(cmds,"cmd /c %s",cmd);
    if (!CreateProcess(NULL,(LPTSTR)cmds,NULL,NULL,FALSE,CREATE_NO_WINDOW,NULL,
                       NULL,&si,&info)) return -1;
    WaitForSingleObject(info.hProcess,INFINITE);
    if (!GetExitCodeProcess(info.hProcess,&stat)) stat=-1;
    CloseHandle(info.hProcess);
    CloseHandle(info.hThread);
    return (int)stat;
#else
    return system(cmd);
#endif
}

static double set_wavelen(int sys, const prcopt_t* popt,int frq, const nav_t* nav,int sat)
{
    int i;
    const double freq_glo[] = { FREQ1_GLO,FREQ2_GLO };
    const double dfrq_glo[] = { DFRQ1_GLO,DFRQ2_GLO };

    if (popt->bds2 == 0 || popt->bds2 == 2) {
        if (sys == SYS_GLO) {
            if (0 <= frq && frq <= 1) { /* L1,L2 */
                for (i = 0; i < nav->ng; i++) {
                    if (nav->geph[i].sat != sat) continue;
                    return CLIGHT / (freq_glo[frq] + dfrq_glo[frq] * nav->geph[i].frq);
                }
            }
            else if (frq == 2) { /* L3 */
                return CLIGHT / FREQ3_GLO;
            }
        }
        if (sys == SYS_CMP) {
            if (frq == 0) return CLIGHT / FREQ1_CMP;      /* B1-2    1.561098E9   */
            else if (frq == 1) return CLIGHT / FREQ3_CMP; /* B3      1.26852E9 */
            else if (frq == 2) return CLIGHT / FREQ2_CMP; /* B2b(BDS-3) 1.20714E9 */
            else if (frq == 3) return CLIGHT / FREQ1;     /* B1 (BDS-3) 1.57542E9 */
            else if (frq == 4) return CLIGHT / FREQ5;     /* B2a(BDS-3) 1.17645E9 */
            else if (frq == 5) return CLIGHT / FREQ2_CMP; /* B2b(BDS-2) 1.20714E9 */
        }
        else if (sys == SYS_GAL) {
            if (frq == 0) return CLIGHT / FREQ1;      /* E1   1.57542E9*/
            else if (frq == 1) return CLIGHT / FREQ5; /* E5a  1.17645E9*/
            else if (frq == 2) return CLIGHT / FREQ7; /* E5b  1.20714E9*/
            else if (frq == 3) return CLIGHT / FREQ6; /* E6   1.27875E9*/
            else if (frq == 4) return CLIGHT / FREQ8; /* E5ab 1.191795E9*/
        }
        else { /* GPS,QZS */
            if (frq == 0) return CLIGHT / FREQ1;      /* L1 1.57542E9 */
            else if (frq == 1) return CLIGHT / FREQ2; /* L2 1.22760E9 */
            else if (frq == 2) return CLIGHT / FREQ5; /* L5 1.17645E9 */
            else if (frq == 3) return CLIGHT / FREQ6; /* L6/LEX 1.27875E9 */
        }
    }
    else if (popt->bds2 == 1) {
        if (sys == SYS_GLO) {
            if (0 <= frq && frq <= 1) { /* L1,L2 */
                for (i = 0; i < nav->ng; i++) {
                    if (nav->geph[i].sat != sat) continue;
                    return CLIGHT / (freq_glo[frq] + dfrq_glo[frq] * nav->geph[i].frq);
                }
            }
            else if (frq == 2) { /* L3 */
                return CLIGHT / FREQ3_GLO;
            }
        }
        if (sys == SYS_CMP) {
            if (frq == 0) return CLIGHT / FREQ1_CMP;      /* B1-2    1.561098E9   */
            else if (frq == 1) return CLIGHT / FREQ3_CMP; /* B3      1.26852E9 */
            else if (frq == 2) return CLIGHT / FREQ2_CMP; /* B2b(BDS-2) 1.20714E9 */
            else if (frq == 3) return CLIGHT / FREQ1;     /* B1 (BDS-3) 1.57542E9 */
            else if (frq == 4) return CLIGHT / FREQ5;     /* B2a(BDS-3) 1.17645E9 */
            else if (frq == 5) return CLIGHT / FREQ2_CMP; /* B2b(BDS-3) 1.20714E9 */
        }
        else if (sys == SYS_GAL) {
            if (frq == 0) return CLIGHT / FREQ1;      /* E1   1.57542E9*/
            else if (frq == 1) return CLIGHT / FREQ5; /* E5a  1.17645E9*/
            else if (frq == 2) return CLIGHT / FREQ7; /* E5b  1.20714E9*/
            else if (frq == 3) return CLIGHT / FREQ6; /* E6   1.27875E9*/
            else if (frq == 4) return CLIGHT / FREQ8; /* E5ab 1.191795E9*/
        }
        else { /* GPS,QZS */
            if (frq == 0) return CLIGHT / FREQ1;      /* L1 1.57542E9 */
            else if (frq == 1) return CLIGHT / FREQ2; /* L2 1.22760E9 */
            else if (frq == 2) return CLIGHT / FREQ5; /* L5 1.17645E9 */
            else if (frq == 3) return CLIGHT / FREQ6; /* L6/LEX 1.27875E9 */
        }
    }
    return 0.0;
}


/* satellite carrier wave length -----------------------------------------------
* get satellite carrier wave lengths
* args   : int    sat       I   satellite number
*          int    frq       I   frequency index (0:L1,1:L2,2:L5/3,...)
*          nav_t  *nav      I   navigation messages
* return : carrier wave length (m) (0.0: error)
*-----------------------------------------------------------------------------*/
extern double satwavelen(int sat,int frq,const nav_t *nav, const prcopt_t* popt)
{
    const double freq_glo[]={FREQ1_GLO,FREQ2_GLO};
    const double dfrq_glo[]={DFRQ1_GLO,DFRQ2_GLO};
    int sys=satsys(sat,NULL);
    double lam = 0.0;

    lam=set_wavelen(sys,popt,frq,nav,sat);

    return lam;
}
/* geometric distance ----------------------------------------------------------
* compute geometric distance and receiver-to-satellite unit vector
* args   : double *rs       I   satellilte position (ecef at transmission) (m)
*          double *rr       I   receiver position (ecef at reception) (m)
*          double *e        O   line-of-sight vector (ecef)
* return : geometric distance (m) (0>:error/no satellite position)
* notes  : distance includes sagnac effect correction
*-----------------------------------------------------------------------------*/
extern double geodist(const double *rs,const double *rr,double *e)
{
    double r;
    int i;
    
    if (norm(rs,3)<RE_WGS84) return -1.0;
    for (i=0;i<3;i++) e[i]=rs[i]-rr[i];
    r=norm(e,3);
    for (i=0;i<3;i++) e[i]/=r;
    return r+OMGE*(rs[0]*rr[1]-rs[1]*rr[0])/CLIGHT;
}
/* satellite azimuth/elevation angle -------------------------------------------
* compute satellite azimuth/elevation angle
* args   : double *pos      I   geodetic position {lat,lon,h} (rad,m)
*          double *e        I   receiver-to-satellilte unit vevtor (ecef)
*          double *azel     IO  azimuth/elevation {az,el} (rad) (NULL: no output)
*                               (0.0<=azel[0]<2*pi,-pi/2<=azel[1]<=pi/2)
* return : elevation angle (rad)
*-----------------------------------------------------------------------------*/
extern double satazel(const double *pos,const double *e,double *azel)
{
    double az=0.0,el=PI/2.0,enu[3];
    
    if (pos[2]>-RE_WGS84) {
        ecef2enu(pos,e,enu);
        az=dot(enu,enu,2)<1E-12?0.0:atan2(enu[0],enu[1]);
        if (az<0.0) az+=2*PI;
        el = asin(enu[2]);
    }
    if (azel) {azel[0]=az; azel[1]=el;}
    return el;
}
/* compute dops ----------------------------------------------------------------
* compute DOP (dilution of precision)
* args   : int    ns        I   number of satellites
*          double *azel     I   satellite azimuth/elevation angle (rad)
*          double elmin     I   elevation cutoff angle (rad)
*          double *dop      O   DOPs {GDOP,PDOP,HDOP,VDOP}
* return : none
* notes  : dop[0]-[3] return 0 in case of dop computation error
*-----------------------------------------------------------------------------*/
extern void dops(int ns,const double *azel,double elmin,double *dop)
{
    double H[4*MAXSAT],Q[16],cosel,sinel;
    int i,n;
    for (i=0;i<4;i++) dop[i]=0.0;
    for (i=n=0;i<ns&&i<MAXSAT;i++) {
        if (azel[1+i*2]<elmin||azel[1+i*2]<=0.0) continue;
        cosel=cos(azel[1+i*2]);
        sinel=sin(azel[1+i*2]);
        H[  4*n]=cosel*sin(azel[i*2]);
        H[1+4*n]=cosel*cos(azel[i*2]);
        H[2+4*n]=sinel;
        H[3+4*n++]=1.0;
    }
    if (n<4) return;
    
    matmul("NT",4,4,n,1.0,H,H,0.0,Q);
    if (!matinv(Q,4)) {
        dop[0]=SQRT(Q[0]+Q[5]+Q[10]+Q[15]); /* GDOP */
        dop[1]=SQRT(Q[0]+Q[5]+Q[10]);       /* PDOP */
        dop[2]=SQRT(Q[0]+Q[5]);             /* HDOP */
        dop[3]=SQRT(Q[10]);                 /* VDOP */
    }
}
/* ionosphere model ------------------------------------------------------------
* compute ionospheric delay by broadcast ionosphere model (klobuchar model)
* args   : gtime_t t        I   time (gpst)
*          double *ion      I   iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3}
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
* return : ionospheric delay (L1) (m)
*-----------------------------------------------------------------------------*/
extern double ionmodel(gtime_t t,const double *ion,const double *pos,const double *azel, const prcopt_t* opt)
{
    const double ion_default[]={ /* 2004/1/1 */
        0.1118E-07,-0.7451E-08,-0.5961E-07, 0.1192E-06,
        0.1167E+06,-0.2294E+06,-0.1311E+06, 0.1049E+07
    };
    double tt,f,psi,phi,lam,amp,per,x;
    int week;
    
    if (pos[2]<-1E3||azel[1]<=0) return 0.0;
    if (norm(ion,8)<=0.0) ion=ion_default;
    
    /* earth centered angle (semi-circle) */
    psi=0.0137/(azel[1]/PI+0.11)-0.022;
    
    /* subionospheric latitude/longitude (semi-circle) */
    phi=pos[0]/PI+psi*cos(azel[0]);
    if      (phi> 0.416) phi= 0.416;
    else if (phi<-0.416) phi=-0.416;
    lam=pos[1]/PI+psi*sin(azel[0])/cos(phi*PI);
    
    /* geomagnetic latitude (semi-circle) */
    phi+=0.064*cos((lam-1.617)*PI);
    
    /* local time (s) */
    tt=43200.0*lam+time2gpst(t,&week);
    tt-=floor(tt/86400.0)*86400.0; /* 0<=tt<86400 */
    
    /* slant factor */
    f=1.0+16.0*pow(0.53-azel[1]/PI,3.0);
    
    /* ionospheric delay */
    amp=ion[0]+phi*(ion[1]+phi*(ion[2]+phi*ion[3]));
    per=ion[4]+phi*(ion[5]+phi*(ion[6]+phi*ion[7]));
    amp=amp<    0.0?    0.0:amp;
    per=per<72000.0?72000.0:per;
    x=2.0*PI*(tt-50400.0)/per;
    
    return CLIGHT*f*(fabs(x)<1.57?5E-9+amp*(1.0+x*x*(-0.5+x*x/24.0)):5E-9);
}
/* ionosphere mapping function -------------------------------------------------
* compute ionospheric delay mapping function by single layer model
* args   : double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
* return : ionospheric mapping function
*-----------------------------------------------------------------------------*/
extern double ionmapf(const double *pos,const double *azel)
{
    if (pos[2]>=HION) return 1.0;
    return 1.0/cos(asin((RE_WGS84+pos[2])/(RE_WGS84+HION)*sin(PI/2.0-azel[1])));
}
/* ionospheric pierce point position -------------------------------------------
* compute ionospheric pierce point (ipp) position and slant factor
* args   : double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double re        I   earth radius (km)
*          double hion      I   altitude of ionosphere (km)
*          double *posp     O   pierce point position {lat,lon,h} (rad,m)
* return : slant factor
* notes  : see ref [2], only valid on the earth surface
*          fixing bug on ref [2] A.4.4.10.1 A-22,23
*-----------------------------------------------------------------------------*/
extern double ionppp(const double *pos,const double *azel,double re,double hion,double *posp)
{
    double cosaz,rp,ap,sinap,tanap;
    
    rp=re/(re+hion)*cos(azel[1]);
    ap=PI/2.0-azel[1]-asin(rp);
    sinap=sin(ap);
    tanap=tan(ap);
    cosaz=cos(azel[0]);
    posp[0]=asin(sin(pos[0])*cos(ap)+cos(pos[0])*sinap*cosaz);
    
    if ((pos[0]> 70.0*D2R&& tanap*cosaz>tan(PI/2.0-pos[0]))||
        (pos[0]<-70.0*D2R&&-tanap*cosaz>tan(PI/2.0+pos[0]))) {
        posp[1]=pos[1]+PI-asin(sinap*sin(azel[0])/cos(posp[0]));
    }
    else {
        posp[1]=pos[1]+asin(sinap*sin(azel[0])/cos(posp[0]));
    }
    return 1.0/sqrt(1.0-rp*rp);
}
/* troposphere model -----------------------------------------------------------
* compute tropospheric delay by standard atmosphere and saastamoinen model
* args   : gtime_t time     I   time
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double humi      I   relative humidity
* return : tropospheric delay (m)
*-----------------------------------------------------------------------------*/
extern double tropmodel(gtime_t time,const double *pos,const double *azel,double humi)
{
    const double temp0=15.0; /* temparature at sea level */
    double hgt,pres,temp,e,z,trph,trpw;
    
    if (pos[2]<-100.0||1E4<pos[2]||azel[1]<=0) return 0.0;
    
    /* standard atmosphere */
    hgt=pos[2]<0.0?0.0:pos[2];
    
    pres=1013.25*pow(1.0-2.2557E-5*hgt,5.2568);
    temp=temp0-6.5E-3*hgt+273.16;
    e=6.108*humi*exp((17.15*temp-4684.0)/(temp-38.45));
    
    /* saastamoninen model */
    z=PI/2.0-azel[1];
    trph=0.0022768*pres/(1.0-0.00266*cos(2.0*pos[0])-0.00028*hgt/1E3)/cos(z);
    trpw=0.002277*(1255.0/temp+0.05)*e/cos(z);
    return trph+trpw;
}
#ifndef IERS_MODEL
/* -------------------------------------------------------------------------
** JULDAY  Conversion of date as given by
**         y ... year (four digits)
**         m ... month
**         d ... day
**         h ... hour and fraction hereof
**         The conversion is only valid in the time span
**         from March 1900 to February 2100
**
** See  Hofmann-Wellenhof et al., p. 41--42
** -------------------------------------------------------------------------*/
extern double julday(double y,double m,double d,double h)
{
	if (m<=2) {
		y=y-1;
		m=m+12;
	}
	return (floor(365.25*y)+floor(30.6001*(m+1))+d+h/24+1720981.5);
}
/* -------------------------------------------------------------------------
**  This subroutine determines the Global Mapping Functions GMF
**  Reference: Boehm, J., A.E. Niell, P. Tregoning, H. Schuh (2006),
**  Global Mapping Functions (GMF): A new empirical mapping function
**  based on numerical weather model data,Geoph. Res. Letters,
**  Vol. 33, L07304, doi:10.1029/2005GL025545.
*/
extern void GMF(double dmjd,const double *pos,double zd,double *gmf)
{
	const double ah_mean[55]={
		 +1.2517e+02, +8.503e-01, +6.936e-02, -6.760e+00, +1.771e-01,
		  +1.130e-02, +5.963e-01, +1.808e-02, +2.801e-03, -1.414e-03,
		  -1.212e+00, +9.300e-02, +3.683e-03, +1.095e-03, +4.671e-05,
		  +3.959e-01, -3.867e-02, +5.413e-03, -5.289e-04, +3.229e-04,
		  +2.067e-05, +3.000e-01, +2.031e-02, +5.900e-03, +4.573e-04,
		  -7.619e-05, +2.327e-06, +3.845e-06, +1.182e-01, +1.158e-02,
		  +5.445e-03, +6.219e-05, +4.204e-06, -2.093e-06, +1.540e-07,
		  -4.280e-08, -4.751e-01, -3.490e-02, +1.758e-03, +4.019e-04,
		  -2.799e-06, -1.287e-06, +5.468e-07, +7.580e-08, -6.300e-09,
		  -1.160e-01, +8.301e-03, +8.771e-04, +9.955e-05, -1.718e-06,
		  -2.012e-06, +1.170e-08, +1.790e-08, -1.300e-09, +1.000e-10};
	const double bh_mean[55]={
		  +0.000e+00, +0.000e+00, +3.249e-02, +0.000e+00, +3.324e-02,
		  +1.850e-02, +0.000e+00, -1.115e-01, +2.519e-02, +4.923e-03,
		  +0.000e+00, +2.737e-02, +1.595e-02, -7.332e-04, +1.933e-04,
		  +0.000e+00, -4.796e-02, +6.381e-03, -1.599e-04, -3.685e-04,
		  +1.815e-05, +0.000e+00, +7.033e-02, +2.426e-03, -1.111e-03,
		  -1.357e-04, -7.828e-06, +2.547e-06, +0.000e+00, +5.779e-03,
		  +3.133e-03, -5.312e-04, -2.028e-05, +2.323e-07, -9.100e-08,
		  -1.650e-08, +0.000e+00, +3.688e-02, -8.638e-04, -8.514e-05,
		  -2.828e-05, +5.403e-07, +4.390e-07, +1.350e-08, +1.800e-09,
		  +0.000e+00, -2.736e-02, -2.977e-04, +8.113e-05, +2.329e-07,
		  +8.451e-07, +4.490e-08, -8.100e-09, -1.500e-09, +2.000e-10};
	const double ah_amp[55]={
		  -2.738e-01, -2.837e+00, +1.298e-02, -3.588e-01, +2.413e-02,
		  +3.427e-02, -7.624e-01, +7.272e-02, +2.160e-02, -3.385e-03,
		  +4.424e-01, +3.722e-02, +2.195e-02, -1.503e-03, +2.426e-04,
		  +3.013e-01, +5.762e-02, +1.019e-02, -4.476e-04, +6.790e-05,
		  +3.227e-05, +3.123e-01, -3.535e-02, +4.840e-03, +3.025e-06,
		  -4.363e-05, +2.854e-07, -1.286e-06, -6.725e-01, -3.730e-02,
		  +8.964e-04, +1.399e-04, -3.990e-06, +7.431e-06, -2.796e-07,
		  -1.601e-07, +4.068e-02, -1.352e-02, +7.282e-04, +9.594e-05,
		  +2.070e-06, -9.620e-08, -2.742e-07, -6.370e-08, -6.300e-09,
		  +8.625e-02, -5.971e-03, +4.705e-04, +2.335e-05, +4.226e-06,
		  +2.475e-07, -8.850e-08, -3.600e-08, -2.900e-09, +0.000e+00};
	const double bh_amp[55]={
		  +0.000e+00, +0.000e+00, -1.136e-01, +0.000e+00, -1.868e-01,
		  -1.399e-02, +0.000e+00, -1.043e-01, +1.175e-02, -2.240e-03,
		  +0.000e+00, -3.222e-02, +1.333e-02, -2.647e-03, -2.316e-05,
		  +0.000e+00, +5.339e-02, +1.107e-02, -3.116e-03, -1.079e-04,
		  -1.299e-05, +0.000e+00, +4.861e-03, +8.891e-03, -6.448e-04,
		  -1.279e-05, +6.358e-06, -1.417e-07, +0.000e+00, +3.041e-02,
		  +1.150e-03, -8.743e-04, -2.781e-05, +6.367e-07, -1.140e-08,
		  -4.200e-08, +0.000e+00, -2.982e-02, -3.000e-03, +1.394e-05,
		  -3.290e-05, -1.705e-07, +7.440e-08, +2.720e-08, -6.600e-09,
		  +0.000e+00, +1.236e-02, -9.981e-04, -3.792e-05, -1.355e-05,
		  +1.162e-06, -1.789e-07, +1.470e-08, -2.400e-09, -4.000e-10};
	const double aw_mean[55]={
		  +5.640e+01, +1.555e+00, -1.011e+00, -3.975e+00, +3.171e-02,
		  +1.065e-01, +6.175e-01, +1.376e-01, +4.229e-02, +3.028e-03,
		  +1.688e+00, -1.692e-01, +5.478e-02, +2.473e-02, +6.059e-04,
		  +2.278e+00, +6.614e-03, -3.505e-04, -6.697e-03, +8.402e-04,
		  +7.033e-04, -3.236e+00, +2.184e-01, -4.611e-02, -1.613e-02,
		  -1.604e-03, +5.420e-05, +7.922e-05, -2.711e-01, -4.406e-01,
		  -3.376e-02, -2.801e-03, -4.090e-04, -2.056e-05, +6.894e-06,
		  +2.317e-06, +1.941e+00, -2.562e-01, +1.598e-02, +5.449e-03,
		  +3.544e-04, +1.148e-05, +7.503e-06, -5.667e-07, -3.660e-08,
		  +8.683e-01, -5.931e-02, -1.864e-03, -1.277e-04, +2.029e-04,
		  +1.269e-05, +1.629e-06, +9.660e-08, -1.015e-07, -5.000e-10};
	const double bw_mean[55]={
		  +0.000e+00, +0.000e+00, +2.592e-01, +0.000e+00, +2.974e-02,
		  -5.471e-01, +0.000e+00, -5.926e-01, -1.030e-01, -1.567e-02,
		  +0.000e+00, +1.710e-01, +9.025e-02, +2.689e-02, +2.243e-03,
		  +0.000e+00, +3.439e-01, +2.402e-02, +5.410e-03, +1.601e-03,
		  +9.669e-05, +0.000e+00, +9.502e-02, -3.063e-02, -1.055e-03,
		  -1.067e-04, -1.130e-04, +2.124e-05, +0.000e+00, -3.129e-01,
		  +8.463e-03, +2.253e-04, +7.413e-05, -9.376e-05, -1.606e-06,
		  +2.060e-06, +0.000e+00, +2.739e-01, +1.167e-03, -2.246e-05,
		  -1.287e-04, -2.438e-05, -7.561e-07, +1.158e-06, +4.950e-08,
		  +0.000e+00, -1.344e-01, +5.342e-03, +3.775e-04, -6.756e-05,
		  -1.686e-06, -1.184e-06, +2.768e-07, +2.730e-08, +5.700e-09};
	const double aw_amp[55]={
		  +1.023e-01, -2.695e+00, +3.417e-01, -1.405e-01, +3.175e-01,
		  +2.116e-01, +3.536e+00, -1.505e-01, -1.660e-02, +2.967e-02,
		  +3.819e-01, -1.695e-01, -7.444e-02, +7.409e-03, -6.262e-03,
		  -1.836e+00, -1.759e-02, -6.256e-02, -2.371e-03, +7.947e-04,
		  +1.501e-04, -8.603e-01, -1.360e-01, -3.629e-02, -3.706e-03,
		  -2.976e-04, +1.857e-05, +3.021e-05, +2.248e+00, -1.178e-01,
		  +1.255e-02, +1.134e-03, -2.161e-04, -5.817e-06, +8.836e-07,
		  -1.769e-07, +7.313e-01, -1.188e-01, +1.145e-02, +1.011e-03,
		  +1.083e-04, +2.570e-06, -2.140e-06, -5.710e-08, +2.000e-08,
		  -1.632e+00, -6.948e-03, -3.893e-03, +8.592e-04, +7.577e-05,
		  +4.539e-06, -3.852e-07, -2.213e-07, -1.370e-08, +5.800e-09};
	const double bw_amp[55]={
		  +0.000e+00, +0.000e+00, -8.865e-02, +0.000e+00, -4.309e-01,
		  +6.340e-02, +0.000e+00, +1.162e-01, +6.176e-02, -4.234e-03,
		  +0.000e+00, +2.530e-01, +4.017e-02, -6.204e-03, +4.977e-03,
		  +0.000e+00, -1.737e-01, -5.638e-03, +1.488e-04, +4.857e-04,
		  -1.809e-04, +0.000e+00, -1.514e-01, -1.685e-02, +5.333e-03,
		  -7.611e-05, +2.394e-05, +8.195e-06, +0.000e+00, +9.326e-02,
		  -1.275e-02, -3.071e-04, +5.374e-05, -3.391e-05, -7.436e-06,
		  +6.747e-07, +0.000e+00, -8.637e-02, -3.807e-03, -6.833e-04,
		  -3.861e-05, -2.268e-05, +1.454e-06, +3.860e-07, -1.068e-07,
		  +0.000e+00, -2.658e-02, -1.947e-03, +7.131e-04, -3.506e-05,
		  +1.885e-07, +5.792e-07, +3.990e-08, +2.000e-08, -5.700e-09};
	int i;
	double bh,c0h,phh,c11h,c10h,ch,ahm,aha,ah;
	double sine,cose,beta,gamma,topcon,gmfh;
	double a_ht,b_ht,c_ht,hs_km,ht_corr_coef,ht_corr;
	double bw,cw,awm,awa,aw,gmfw;
	//=======================================================================
	//
	//=======================================================================
	// reference day is 28 January
	// this is taken from Niell (1996) to be consistent
	//-----------------------------------------------------------------------
	double doy=dmjd-44266.0;
	//=======================================================================
	//
	//=======================================================================
	// degree n and order m
	//-----------------------------------------------------------------------
	int nmax=9,n;
	int mmax=9,m;
	double V[10][10]={0},W[10][10]={0};
	//=======================================================================
	//
	//=======================================================================
	// unit vector
	//-----------------------------------------------------------------------
	double x=cos(pos[0])*cos(pos[1]);
	double y=cos(pos[0])*sin(pos[1]);
	double z=sin(pos[0]);
	gmf[0]=gmf[1]=0;
	//=======================================================================
	//
	//=======================================================================
	// Legendre polynomials
	//-----------------------------------------------------------------------
	V[0][0]=1.0;
	W[0][0]=0.0;
	V[1][0]=z*V[0][0];
	W[1][0]=0.0;
	for (n=2;n<=nmax;++n) {
		V[n][0]=((2*n-1)*z*V[n-1][0]-(n-1)*V[n-2][0])/n;
		W[n][0]=0.0;
	}
	for (m=1;m<=nmax;++m) {
		V[m][m]=(2*m-1)*(x*V[m-1][m-1]-y*W[m-1][m-1]);
		W[m][m]=(2*m-1)*(x*W[m-1][m-1]+y*V[m-1][m-1]);
		if (m<nmax) {
			V[m+1][m]=(2*m+1)*z*V[m][m];
			W[m+1][m]=(2*m+1)*z*W[m][m];
		}
		for (n=m+2;n<=nmax;++n) {
			V[n][m]=((2*n-1)*z*V[n-1][m]-(n+m-1)*V[n-2][m])/(n-m);
			W[n][m]=((2*n-1)*z*W[n-1][m]-(n+m-1)*W[n-2][m])/(n-m);
		}
	}
	//=======================================================================
	//
	//=======================================================================
	// hydrostatic
	//-----------------------------------------------------------------------
	bh =0.0029;
	c0h=0.0620;
	if (pos[0]<0) { /* southern hemisphere */
		phh =PI;
		c11h=0.007;
		c10h=0.002;
	}
	else {          /* northern hemisphere */
		phh =0;
		c11h=0.005;
		c10h=0.001;
	}
	ch=c0h+((cos(doy/365.25*2*PI+phh)+1)*c11h/2+c10h)*(1-cos(pos[0]));
	ahm=0.0;
	aha=0.0;
	for (n=i=0;n<=nmax;++n) for (m=0;m<=n;++m) {
		ahm=ahm+(ah_mean[i]*V[n][m]+bh_mean[i]*W[n][m]);
		aha=aha+(ah_amp [i]*V[n][m]+bh_amp [i]*W[n][m]);
		++i;
	}
	ah=(ahm+aha*cos(doy/365.250*2.0*PI))*1e-5;

	sine  =sin(PI/2-zd);
	cose  =cos(PI/2-zd);
	beta  =bh/(sine+ch);
	gamma =ah/(sine+beta);
	topcon=(1.0+ah/(1.0+bh/(1.0+ch)));
	gmfh  =topcon/(sine+gamma);
	//=======================================================================
	//
	//=======================================================================
	// height correction for hydrostatic mapping function from Niell (1996)
	//-----------------------------------------------------------------------
	a_ht =2.53e-5;
	b_ht =5.49e-3;
	c_ht =1.14e-3;
	hs_km=pos[2]/1000.0;

	beta   =b_ht/(sine+c_ht);
	gamma  =a_ht/(sine+beta);
	topcon =(1.0+a_ht/(1.0+b_ht/(1.0+c_ht)));
	ht_corr_coef=1/sine-topcon/(sine+gamma);
	ht_corr=ht_corr_coef*hs_km;
	gmfh   =gmfh+ht_corr;
	gmf[0] =gmfh;
	//=======================================================================
	//
	//=======================================================================
	// wet
	//-----------------------------------------------------------------------
	bw =0.00146;
	cw =0.04391;
	awm=0.0;
	awa=0.0;
	for (n=i=0;n<=nmax;++n) for (m=0;m<=n;++m) {
		awm=awm+(aw_mean[i]*V[n][m]+bw_mean[i]*W[n][m]);
		awa=awa+(aw_amp [i]*V[n][m]+bw_amp [i]*W[n][m]);
		++i;
	}
	aw=(awm+awa*cos(doy/365.250*2*PI))*1e-5;

	beta  =bw/(sine+cw);
	gamma =aw/(sine+beta);
	topcon=(1.0+aw/(1.0+bw/(1.0+cw)));
	gmfw  =topcon/(sine+gamma);
	gmf[1]=gmfw;
}
/* -------------------------------------------------------------------------
** Input/Output
** ------------
**
**   PARAMETER   I/O   TYPE       DESCRIPTION
**   ---------   ---   ----       -----------
**   LATRAD      SCBN    DOUBLE     Station geodetic latitude  (radians)
**   LONGITUDE   SCBN    DOUBLE     Station geodetic longitude (radians)
**   HEIGHTM     SCBN    DOUBLE     Station orthometric height (m)  ()
**   YEAR        SCBN    DOUBLE     Year
**   DAYOYEAR    SCBN    DOUBLE     Day of year
**   ELEVRAD     SCBN    DOUBLE     Elevation angle (radians)
**   HZD         OUT   DOUBLE     Hydrostatic zenith delay (m)
**   HMF         OUT   DOUBLE     Hydrostatic Niell mapping function
**   WZD         OUT   DOUBLE     Non-hyd. zenith delay (m)
**   WMF         OUT   DOUBLE     Non-hyd. Niell mapping function
**   RTROP       OUT   DOUBLE     Total slant delay (m)
** -------------------------------------------------------------------------*/
extern void UNB3M(const double *pos,double DAYOYEAR,double *TZD)
{
	double LATRAD=pos[0],LONGITUDE=pos[1],HEIGHTM=pos[2];
	int P1,P2;
	double PAVG,TAVG,EAVG,BETAAVG,LAMBDAAVG,M;
	double PAMP,TAMP,EAMP,BETAAMP,LAMBDAAMP;
	double P0,T0,E0,BETA,LAMBDA,ES,FW,EP,T,P,E,GEOLAT,DGREF,GM,DEN,TM;

	//=======================================================================
	// Initialize UNB3m look - up table
	//-----------------------------------------------------------------------
	const double AVG[5][6]={{15.0, 1013.25, 299.65,  75.00,   6.30,   2.77},
	                        {30.0, 1017.25, 294.15,  80.00,   6.05,   3.15},
							{45.0, 1015.75, 283.15,  76.00,   5.58,   2.57},
							{60.0, 1011.75, 272.15,  77.50,   5.39,   1.81},
							{75.0, 1013.00, 263.65,  82.50,   4.53,   1.55}};
	/*                        lat     P       T       RH      beta   lambda*/
	const double AMP[5][6]={{15.0,  0.00,  0.00,  0.00, 0.00, 0.00},
		                    {30.0, -3.75,  7.00,  0.00, 0.25, 0.33},
		                    {45.0, -2.25, 11.00, -1.00, 0.32, 0.46},
		                    {60.0, -1.75, 15.00, -2.50, 0.81, 0.74},
		                    {75.0, -0.50, 14.50,  2.50, 0.62, 0.30}};
	/*                        lat    P      T      RH   beta  lambda*/
	//=======================================================================
	//
	//=======================================================================
	const double EXCEN2 = 6.6943799901413e-03;
	const double MD     = 28.9644;
	const double MW     = 18.0152;
	const double K1     = 77.604;
	const double K2     = 64.79;
	const double K3     = 3.776e5;
	const double R      = 8314.34;
	const double C1     = 2.2768e-03;
	const double DTR    = 1.745329251994329e-02;
	const double DOY2RAD=(0.31415926535897935601e01)*2/365.25;
	double K2PRIM=K2-K1*(MW/MD);
	double RD    =R/MD;
	//=======================================================================
	//
	//=======================================================================
	// Initialize NMF tables
	//-----------------------------------------------------------------------
	const double ABC_AVG[5][4]={{15.0, 1.2769934e-3, 2.9153695e-3, 62.610505e-3},
								{30.0, 1.2683230e-3, 2.9152299e-3, 62.837393e-3},
								{45.0, 1.2465397e-3, 2.9288445e-3, 63.721774e-3},
								{60.0, 1.2196049e-3, 2.9022565e-3, 63.824265e-3},
								{75.0, 1.2045996e-3, 2.9024912e-3, 64.258455e-3}};
	const double ABC_AMP[5][4]={{15.0, 0.0         , 0.0         , 0.0         },
                                {30.0, 1.2709626e-5, 2.1414979e-5, 9.0128400e-5},
                                {45.0, 2.6523662e-5, 3.0160779e-5, 4.3497037e-5},
                                {60.0, 3.4000452e-5, 7.2562722e-5, 84.795348e-5},
                                {75.0, 4.1202191e-5, 11.723375e-5, 170.37206e-5}};
	const double A_HT=2.53e-5;
	const double B_HT=5.49e-3;
	const double C_HT=1.14e-3;
	double HT_TOPCON=1+A_HT/(1+B_HT/(1+C_HT));

	const double ABC_W2P0[5][4]={{15.0, 5.8021897e-4, 1.4275268e-3, 4.3472961e-2},
								 {30.0, 5.6794847e-4, 1.5138625e-3, 4.6729510e-2},
								 {45.0, 5.8118019e-4, 1.4572752e-3, 4.3908931e-2},
								 {60.0, 5.9727542e-4, 1.5007428e-3, 4.4626982e-2},
								 {75.0, 6.1641693e-4, 1.7599082e-3, 5.4736038e-2}};
	//=======================================================================
	//
	//=======================================================================
	// Transform latitude from radians to decimal degrees
	//-----------------------------------------------------------------------
	double LATDEG=LATRAD*180.0/PI;
	//=======================================================================
	//
	//=======================================================================
	// Deal with southern hemisphere and yearly variation
	//-----------------------------------------------------------------------
	double TD_O_Y=LATDEG<0?(DAYOYEAR+182.625):DAYOYEAR;
	double COSPHS=cos((TD_O_Y-28)*DOY2RAD);
	//=======================================================================
	//
	//=======================================================================
	// Initialize pointers to lookup table
	//-----------------------------------------------------------------------
	double LAT=fabs(LATDEG);
	if (LAT>=75) {
		P1=4; //5-1
		P2=4; //5-1
		M =0;
	}
	else if (LAT<=15) {
		P1=0; //1-1
		P2=0; //1-1
		M =0;
	}
	else {
		P1=(int)((LAT-15)/15); //P1=fix((LAT-15)/15)+1;
		P2=P1+1; //P2=P1+1;
		M =(LAT-AVG[P1][0])/(AVG[P2][0]-AVG[P1][0]); //M=(LAT-AVG(P1,1))/(AVG(P2,1)-AVG(P1,1));
	}
	//=======================================================================
	//
	//=======================================================================
	// Compute average surface tropo values by interpolation
	//-----------------------------------------------------------------------
	PAVG     =M*(AVG[P2][1]-AVG[P1][1])+AVG[P1][1];
	TAVG     =M*(AVG[P2][2]-AVG[P1][2])+AVG[P1][2];
	EAVG     =M*(AVG[P2][3]-AVG[P1][3])+AVG[P1][3];
	BETAAVG  =M*(AVG[P2][4]-AVG[P1][4])+AVG[P1][4];
	LAMBDAAVG=M*(AVG[P2][5]-AVG[P1][5])+AVG[P1][5];
	//=======================================================================
	//
	//=======================================================================
	// Compute variation of average surface tropo values
	//-----------------------------------------------------------------------
	PAMP     =M*(AMP[P2][1]-AMP[P1][1])+AMP[P1][1];
	TAMP     =M*(AMP[P2][2]-AMP[P1][2])+AMP[P1][2];
	EAMP     =M*(AMP[P2][3]-AMP[P1][3])+AMP[P1][3];
	BETAAMP  =M*(AMP[P2][4]-AMP[P1][4])+AMP[P1][4];
	LAMBDAAMP=M*(AMP[P2][5]-AMP[P1][5])+AMP[P1][5];
	//=======================================================================
	//
	//=======================================================================
	// Compute surface tropo values
	//-----------------------------------------------------------------------
	P0    =PAVG-PAMP*COSPHS;
	T0    =TAVG-TAMP*COSPHS;
	E0    =EAVG-EAMP*COSPHS;
	BETA  =BETAAVG-BETAAMP*COSPHS;
	BETA  =BETA/1000;
	LAMBDA=LAMBDAAVG-LAMBDAAMP*COSPHS;
	//=======================================================================
	//
	//=======================================================================
	// Transform from relative humidity to WVP (IERS Conventions 2003)
	//-----------------------------------------------------------------------
    double asd=1.2378847e-5*(T0*T0)-0.019121316*T0+33.93711047-6343.1645/T0;
    asd=exp(asd);
    ES=0.01*exp(1.2378847e-5*(T0*T0)-0.019121316*T0+33.93711047-6343.1645/T0);
	FW=1.00062+3.14e-6*P0+5.6e-7*pow(T0-273.15,2);
	E0=0.01*E0*ES*FW;
	//=======================================================================
	//
	//=======================================================================
	// Compute power value for pressure & water vapour
	//-----------------------------------------------------------------------
	EP=9.80665/287.054/BETA;
	//=======================================================================
	//
	//=======================================================================
	// Scale surface values to required height
	//-----------------------------------------------------------------------
	T=T0-BETA*HEIGHTM;
	P=P0*pow(T/T0,EP);
	E=E0*pow(T/T0,EP*(LAMBDA+1));
	//=======================================================================
	//
	//=======================================================================
	// Compute the acceleration at the mass center
	// of a vertical column of the atmosphere
	//-----------------------------------------------------------------------
	GEOLAT=atan((1.0-EXCEN2)*tan(LATRAD));
	DGREF =1.0-2.66e-03*cos(2.0*GEOLAT)-2.8e-07*HEIGHTM;
	GM    =9.784*DGREF;
	DEN   =(LAMBDA+1.0)*GM;
	//=======================================================================
	//
	//=======================================================================
	// Compute mean temperature of the water vapor
	//-----------------------------------------------------------------------
	TM=T*(1-BETA*RD/DEN);
	//=======================================================================
	//
	//=======================================================================
	// Compute zenith hydrostatic delay
	//-----------------------------------------------------------------------
	TZD[0]=C1/DGREF*P;
	//=======================================================================
	//
	//=======================================================================
	// Compute zenith wet delay
	//-----------------------------------------------------------------------
	TZD[1]=1.0e-6*(K2PRIM+K3/TM)*RD*E/DEN;
}
static double interpc(const double coef[],double lat)
{
    int i=(int)(lat/15.0);
    if (i<1) return coef[0]; else if (i>4) return coef[4];
    return coef[i-1]*(1.0-lat/15.0+i)+coef[i]*(lat/15.0-i);
}
static double mapf(double el,double a,double b,double c)
{
    double sinel=sin(el);
    return (1.0+a/(1.0+b/(1.0+c)))/(sinel+(a/(sinel+b/(sinel+c))));
}
static double nmf(gtime_t time,const double pos[],const double azel[],double *mapfw)
{
    /* ref [5] table 3 */
    /* hydro-ave-a,b,c, hydro-amp-a,b,c, wet-a,b,c at latitude 15,30,45,60,75 */
    const double coef[][5]={
        { 1.2769934E-3, 1.2683230E-3, 1.2465397E-3, 1.2196049E-3, 1.2045996E-3},
        { 2.9153695E-3, 2.9152299E-3, 2.9288445E-3, 2.9022565E-3, 2.9024912E-3},
        { 62.610505E-3, 62.837393E-3, 63.721774E-3, 63.824265E-3, 64.258455E-3},
        
        { 0.0000000E-0, 1.2709626E-5, 2.6523662E-5, 3.4000452E-5, 4.1202191E-5},
        { 0.0000000E-0, 2.1414979E-5, 3.0160779E-5, 7.2562722E-5, 11.723375E-5},
        { 0.0000000E-0, 9.0128400E-5, 4.3497037E-5, 84.795348E-5, 170.37206E-5},
        
        { 5.8021897E-4, 5.6794847E-4, 5.8118019E-4, 5.9727542E-4, 6.1641693E-4},
        { 1.4275268E-3, 1.5138625E-3, 1.4572752E-3, 1.5007428E-3, 1.7599082E-3},
        { 4.3472961E-2, 4.6729510E-2, 4.3908931E-2, 4.4626982E-2, 5.4736038E-2}
    };
    const double aht[]={ 2.53E-5, 5.49E-3, 1.14E-3}; /* height correction */
    
    double y,cosy,ah[3],aw[3],dm,el=azel[1],lat=pos[0]*R2D,hgt=pos[2];
    int i;
    
    if (el<=0.0) {
        if (mapfw) *mapfw=0.0;
        return 0.0;
    }
    /* year from doy 28, added half a year for southern latitudes */
    y=(time2doy(time)-28.0)/365.25+(lat<0.0?0.5:0.0);
    
    cosy=cos(2.0*PI*y);
    lat=fabs(lat);
    
    for (i=0;i<3;i++) {
        ah[i]=interpc(coef[i  ],lat)-interpc(coef[i+3],lat)*cosy;
        aw[i]=interpc(coef[i+6],lat);
    }
    /* ellipsoidal height is used instead of height above sea level */
    dm=(1.0/sin(el)-mapf(el,aht[0],aht[1],aht[2]))*hgt/1E3;
    
    if (mapfw) *mapfw=mapf(el,aw[0],aw[1],aw[2]);
    
    return mapf(el,ah[0],ah[1],ah[2])+dm;
}
#endif /* !IERS_MODEL */

/* troposphere mapping function ------------------------------------------------
* compute tropospheric mapping function by NMF
* args   : gtime_t t        I   time
*          double *pos      I   receiver position {lat,lon,h} (rad,m)
*          double *azel     I   azimuth/elevation angle {az,el} (rad)
*          double *mapfw    IO  wet mapping function (NULL: not output)
* return : dry mapping function
* note   : see ref [5] (NMF) and [9] (GMF)
*          original JGR paper of [5] has bugs in eq.(4) and (5). the corrected
*          paper is obtained from:
*          ftp://web.haystack.edu/pub/aen/nmf/NMF_JGR.pdf
*-----------------------------------------------------------------------------*/
extern double tropmapf(gtime_t time,const double pos[],const double azel[],double *mapfw)
{
    if (pos[2]<-1000.0||pos[2]>20000.0) {
        if (mapfw) *mapfw=0.0;
        return 0.0;
    }
	return nmf(time,pos,azel,mapfw); /* NMF */
}
/* interpolate antenna phase center variation --------------------------------*/
static double interpvar(double ang,const double *var)
{
    double a=ang/5.0; /* ang=0-90 */
    int i=(int)a;
    if (i<0) return var[0]; else if (i>=18) return var[18];
    return var[i]*(1.0-a+i)+var[i+1]*(a-i);
}
/* receiver antenna model ------------------------------------------------------
* compute antenna offset by antenna phase center parameters
* args   : pcv_t *pcv       I   antenna phase center parameters
*          double *azel     I   azimuth/elevation for receiver {az,el} (rad)
*          int     opt      I   option (0:only offset,1:offset+pcv)
*          double *dant     O   range offsets for each frequency (m)
* return : none
* notes  : current version does not support azimuth dependent terms
*-----------------------------------------------------------------------------*/
extern void antmodel(const _pcv_t *pcv,const double *del,const double *azel,int opt,double *dant)
{
    double e[3],off[3],cosel=cos(azel[1]);
	double el,el1,el2,az,az1,az2,var,var0,var1,var00,var01,var10,var11;
    int i,j,i1,i2,j1,j2;
    
    e[0]=sin(azel[0])*cosel;
    e[1]=cos(azel[0])*cosel;
    e[2]=sin(azel[1]);
    for (i=0;i<NFREQ;i++) {
        for (j=0;j<3;j++) off[j]=pcv->off[i][j]+del[j];
        if      (pcv->num[i]==1) {
            dant[i]=-dot(off,e,3)+(opt?interpvar(90.0-azel[1]*R2D,pcv->var[i][0]):0.0);
		}
        else if (pcv->num[i]==73) {
			el=90.0-azel[1]*R2D;
			az=azel[0]*R2D;
			i1=(int)floor(az/5.0);
			if (i1<0) {
				i1=i2=0;
			}
			else {
				i2=i1>=72?i1:i1+1;
			}
			j1=(int)floor(el/5.0);
			j2=j1>=18?j1:j1+1;

			az1=i1*5.0; az2=i2*5.0;
			el1=j1*5.0; el2=j2*5.0;

            var00=pcv->var[i][i1][j1]; var01=pcv->var[i][i1][j2];
            var10=pcv->var[i][i2][j1]; var11=pcv->var[i][i2][j2];

			if (i1==i2) {
				var=(j1==j2?var00:((el2-el)/(el2-el1)*var00+(el-el1)/(el2-el1)*var01));
			}
			else {
				if (j1==j2) {
					var=(az2-az)/(az2-az1)*var00+(az-az1)/(az2-az1)*var10;
				}
				else { /* Bilinear Interpolations */
					var0=(el2-el)/(el2-el1)*var00+(el-el1)/(el2-el1)*var01;
					var1=(el2-el)/(el2-el1)*var10+(el-el1)/(el2-el1)*var11;
					var =(az2-az)/(az2-az1)*var0 +(az-az1)/(az2-az1)*var1;
				}
			}
			dant[i]=-dot(off,e,3)+(opt?var:0.0);
		}
    }
}
/* satellite antenna model ------------------------------------------------------
* compute satellite antenna phase center parameters
* args   : pcv_t *pcv       I   antenna phase center parameters
*          double nadir     I   nadir angle for satellite (rad)
*          double *dant     O   range offsets for each frequency (m)
* return : none
*-----------------------------------------------------------------------------*/
extern void antmodel_s(const pcv_t *pcv,double nadir,double *dant)
{
    int i;
    
    for (i=0;i<NFREQ;i++) {
        dant[i]=interpvar(nadir*R2D*5.0,pcv->var[i]);
    }
}


/* uncompress file -------------------------------------------------------------
* uncompress (uncompress/unzip/uncompact hatanaka-compression/tar) file
* args   : char   *file     I   input file
*          char   *uncfile  O   uncompressed file
* return : status (-1:error,0:not compressed file,1:uncompress completed)
* note   : creates uncompressed file in tempolary directory
*          gzip and crx2rnx commands have to be installed in commands path
*-----------------------------------------------------------------------------*/
extern int rcb_uncompress(const char *file,char *uncfile)
{
    int stat=0;
    char *p,cmd[2048]="",tmpfile[1024]="",buff[1024],*fname;
    const char* dir = "";
    
    strcpy(tmpfile,file);
    if (!(p=strrchr(tmpfile,'.'))) return 0;
    
    /* uncompress by gzip */
    if (!strcmp(p,".z"  )||!strcmp(p,".Z"  )||
        !strcmp(p,".gz" )||!strcmp(p,".GZ" )||
        !strcmp(p,".zip")||!strcmp(p,".ZIP")) {
        
        strcpy(uncfile,tmpfile); uncfile[p-tmpfile]='\0';
        sprintf(cmd,"gzip -f -d -c \"%s\" > \"%s\"",tmpfile,uncfile);
        
        if (execcmd(cmd)) {
            remove(uncfile);
            return -1;
        }
        strcpy(tmpfile,uncfile);
        stat=1;
    }
    /* extract tar file */
    if ((p=strrchr(tmpfile,'.'))&&!strcmp(p,".tar")) {
        
        strcpy(uncfile,tmpfile); uncfile[p-tmpfile]='\0';
        strcpy(buff,tmpfile);
        fname=buff;
#ifdef WIN32
        if ((p=strrchr(buff,'\\'))) {
            *p='\0'; dir=fname; fname=p+1;
        }
        sprintf(cmd,"set PATH=%%CD%%;%%PATH%% & cd /D \"%s\" & tar -xf \"%s\"",
                dir,fname);
#else
        if ((p=strrchr(buff,'/'))) {
            *p='\0'; dir=fname; fname=p+1;
        }
        sprintf(cmd,"tar -C \"%s\" -xf \"%s\"",dir,tmpfile);
#endif
        if (execcmd(cmd)) {
            if (stat) remove(tmpfile);
            return -1;
        }
        if (stat) remove(tmpfile);
        stat=1;
    }
    /* extract hatanaka-compressed file by cnx2rnx */
    else if ((p=strrchr(tmpfile,'.'))&&strlen(p)>3&&(*(p+3)=='d'||*(p+3)=='D')) {
        
        strcpy(uncfile,tmpfile);
        uncfile[p-tmpfile+3]=*(p+3)=='D'?'O':'o';
        sprintf(cmd,"crx2rnx < \"%s\" > \"%s\"",tmpfile,uncfile);
        
        if (execcmd(cmd)) {
            remove(uncfile);
            if (stat) remove(tmpfile);
            return -1;
        }
        if (stat) remove(tmpfile);
        stat=1;
    }
    return stat;
}
/* satellite antenna phase center offset ---------------------------------------
* compute satellite antenna phase center offset in ecef
* args   : gtime_t time       I   time (gpst)
*          double *rs         I   satellite position and velocity (ecef)
*                                 {x,y,z,vx,vy,vz} (m|m/s)
*          int    sat         I   satellite number
*          nav_t  *nav        I   navigation data
*          double *dant       I   satellite antenna phase center offset (ecef)
*                                 {dx,dy,dz} (m) (iono-free LC value)
* return : none
*-----------------------------------------------------------------------------*/
extern void satantoff(const double *rs,const double *rsun,const pcv_t *pcv,double *dant)
{
    double ex[3],ey[3],ez[3],es[3],r[3];
    int i,j;

    /* unit vectors of satellite fixed coordinates */
    for (i=0;i<3;i++) r[i]=-rs[i];
    if (!normv3(r,ez)) return;
    for (i=0;i<3;i++) r[i]=rsun[i]-rs[i];
    if (!normv3(r,es)) return;
    cross3(ez,es,r);
    if (!normv3(r,ey)) return;
    cross3(ey,ez,ex);

    for (i=0;i<NFREQ;++i) for (j=0;j<3;++j) {
        dant[i*3+j]=pcv->off[i][0]*ex[j]+pcv->off[i][1]*ey[j]+pcv->off[i][2]*ez[j];
    }
}
